[
  {
    "className": "module-info.class",
    "errorType": "NoClassDefFoundError",
    "errorMessage": "META-INF/versions/9/module-info is not a class because access_flag ACC_MODULE is set"
  },
  {
    "className": "org.assertj.core.annotations.Beta",
    "methods": [],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "Abstract2DArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractArrayAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractAtomicFieldUpdaterAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractAtomicReferenceAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractBigDecimalAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractBigDecimalScaleAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractBigIntegerAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractBooleanArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"boolean[]\" in class file org/assertj/core/api/AbstractBooleanArrayAssert"
  },
  {
    "className": "AbstractBooleanAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractByteArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"byte[]\" in class file org/assertj/core/api/AbstractByteArrayAssert"
  },
  {
    "className": "AbstractByteAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractCharacterAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractCharArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"char[]\" in class file org/assertj/core/api/AbstractCharArrayAssert"
  },
  {
    "className": "AbstractCharSequenceAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/CharSequence[]\" in class file org/assertj/core/api/AbstractCharSequenceAssert"
  },
  {
    "className": "AbstractClassAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractClassAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractCollectionAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractCollectionAssert has illegal signature \"methodtype: int __METHODTYPE__(java.lang.Object,java.lang.Object)\""
  },
  {
    "className": "AbstractComparableAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractCompletableFutureAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractDateAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractDateAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractDoubleArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"double[]\" in class file org/assertj/core/api/AbstractDoubleArrayAssert"
  },
  {
    "className": "AbstractDoubleAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractDurationAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractEnumerableAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractFileAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractFileSizeAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractFloatArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"float[]\" in class file org/assertj/core/api/AbstractFloatArrayAssert"
  },
  {
    "className": "AbstractFloatAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractFutureAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractInputStreamAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractInputStreamAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractInstantAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractInstantAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractIntArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"int[]\" in class file org/assertj/core/api/AbstractIntArrayAssert"
  },
  {
    "className": "AbstractIntegerAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractIterableAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractIterableAssert has illegal signature \"methodtype: void __METHODTYPE__(int)\""
  },
  {
    "className": "AbstractIterableSizeAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractIteratorAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractIteratorAssert has illegal signature \"methodtype: void __METHODTYPE__()\""
  },
  {
    "className": "AbstractListAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractCollectionAssert has illegal signature \"methodtype: int __METHODTYPE__(java.lang.Object,java.lang.Object)\""
  },
  {
    "className": "AbstractLocalDateAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractLocalDateAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractLocalDateTimeAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractLocalDateTimeAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractLocalTimeAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractLocalTimeAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractLongAdderAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractLongArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"long[]\" in class file org/assertj/core/api/AbstractLongArrayAssert"
  },
  {
    "className": "AbstractLongAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractMapAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractMapAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object,java.lang.Object)\""
  },
  {
    "className": "AbstractMapSizeAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractMatcherAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractObjectArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/Object[]\" in class file org/assertj/core/api/AbstractObjectArrayAssert"
  },
  {
    "className": "AbstractObjectAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractOffsetDateTimeAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractOffsetTimeAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractOptionalAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractOptionalDoubleAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractOptionalIntAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractOptionalLongAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractPathAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractPeriodAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractPredicateAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractPredicateLikeAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractShortArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"short[]\" in class file org/assertj/core/api/AbstractShortArrayAssert"
  },
  {
    "className": "AbstractShortAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractSoftAssertions.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/SoftAssertionsProvider has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractSpliteratorAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractStringAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/CharSequence[]\" in class file org/assertj/core/api/AbstractCharSequenceAssert"
  },
  {
    "className": "AbstractTemporalAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractThrowableAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractThrowableAssert has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractUniversalComparableAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractUriAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractUrlAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AbstractYearMonthAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractYearMonthAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AbstractZonedDateTimeAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/Object[]\" in class file org/assertj/core/api/AbstractZonedDateTimeAssert"
  },
  {
    "className": "org.assertj.core.api.AfterAssertionErrorCollected",
    "methods": [
      {
        "name": "onAssertionErrorCollected",
        "returnType": "void"
      }
    ],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "org.assertj.core.api.Array2DAssert",
    "methods": [
      {
        "name": "isEmpty",
        "returnType": "void"
      },
      {
        "name": "hasSameDimensionsAs",
        "returnType": "org.assertj.core.api.Array2DAssert"
      },
      {
        "name": "isNotEmpty",
        "returnType": "org.assertj.core.api.Array2DAssert"
      },
      {
        "name": "isNullOrEmpty",
        "returnType": "void"
      },
      {
        "name": "hasNumberOfRows",
        "returnType": "org.assertj.core.api.Array2DAssert"
      },
      {
        "name": "hasDimensions",
        "returnType": "org.assertj.core.api.Array2DAssert"
      }
    ],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "org.assertj.core.api.ArraySortedAssert",
    "methods": [
      {
        "name": "isSorted",
        "returnType": "org.assertj.core.api.ArraySortedAssert"
      },
      {
        "name": "isSortedAccordingTo",
        "returnType": "org.assertj.core.api.ArraySortedAssert"
      }
    ],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "Assert.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/Descriptable.as(Lorg/assertj/core/description/Description;)Ljava/lang/Object; @0: invokeinterface\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/Descriptable\u0027, \u0027org/assertj/core/description/Description\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b900 1202 00b0                         \n"
  },
  {
    "className": "org.assertj.core.api.AssertDelegateTarget",
    "methods": [],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "AssertFactory$ValueProvider.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/api/AssertFactory$ValueProvider.apply(Ljava/lang/reflect/Type;)Ljava/lang/Object; @31: aload\n  Reason:\n    Type top (current frame, locals[5]) is not assignable to reference type\n  Current Frame:\n    bci: @31\n    flags: { }\n    locals: { \u0027org/assertj/core/api/AssertFactory$ValueProvider\u0027, \u0027java/lang/reflect/Type\u0027, integer, integer }\n    stack: { uninitialized 20, uninitialized 20, \u0027java/lang/StringBuilder\u0027 }\n  Bytecode:\n    0000000: 2bc1 000a 3d1c 03a0 0040 2bc1 000c 3e1d\n    0000010: 03a0 0036 bb00 0e59 bb00 1059 b700 1419\n    0000020: 0512 16b6 001a 3a05 b900 2001 0019 0519\n    0000030: 06b6 0023 3a07 1907 b600 273a 08c0 000e\n    0000040: b700 2ac0 002c bfb9 002f 0200 b0       \n  Stackmap Table:\n    append_frame(@71,Integer)\n"
  },
  {
    "className": "AssertFactory.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/AssertFactory.createAssert(Lorg/assertj/core/api/AssertFactory$ValueProvider;)Lorg/assertj/core/api/Assert; @0: checkcast\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/AssertFactory\u0027, \u0027org/assertj/core/api/AssertFactory$ValueProvider\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: c000 09b9 000f 0200 b900 1102 00b0     \n"
  },
  {
    "className": "AssertionErrorCollector.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/AssertionErrorCollector.getDelegate()Ljava/util/Optional; @4: areturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @4\n    flags: { }\n    locals: { \u0027org/assertj/core/api/AssertionErrorCollector\u0027, \u0027java/util/Optional\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b800 0d4c b0                           \n"
  },
  {
    "className": "org.assertj.core.api.AssertionInfo",
    "methods": [
      {
        "name": "description",
        "returnType": "org.assertj.core.description.Description"
      },
      {
        "name": "overridingErrorMessage",
        "returnType": "java.lang.String"
      },
      {
        "name": "representation",
        "returnType": "org.assertj.core.presentation.Representation"
      }
    ],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "Assertions.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/Assertions has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AssertionsForClassTypes.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/api/AssertionsForClassTypes.offset(Ljava/lang/Double;)Lorg/assertj/core/data/Offset; @4: aload_1\n  Reason:\n    Type top (current frame, locals[1]) is not assignable to reference type\n  Current Frame:\n    bci: @4\n    flags: { }\n    locals: { \u0027java/lang/Double\u0027 }\n    stack: { \u0027java/lang/Number\u0027 }\n  Bytecode:\n    0000000: 2ac0 011e 2bb8 0124 4db0               \n"
  },
  {
    "className": "AssertionsForInterfaceTypes.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/api/AssertionsForClassTypes.offset(Ljava/lang/Double;)Lorg/assertj/core/data/Offset; @4: aload_1\n  Reason:\n    Type top (current frame, locals[1]) is not assignable to reference type\n  Current Frame:\n    bci: @4\n    flags: { }\n    locals: { \u0027java/lang/Double\u0027 }\n    stack: { \u0027java/lang/Number\u0027 }\n  Bytecode:\n    0000000: 2ac0 011e 2bb8 0124 4db0               \n"
  },
  {
    "className": "AssertJProxySetup.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/ErrorCollector has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "org.assertj.core.api.AssertProvider",
    "methods": [
      {
        "name": "assertThat",
        "returnType": "java.lang.Object"
      }
    ],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "AssumptionExceptionFactory.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/AssumptionExceptionFactory.\u003cclinit\u003e()V @3: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @3\n    flags: { }\n    locals: { }\n    stack: { \u0027org/assertj/core/configuration/PreferredAssumptionException\u0027 }\n  Bytecode:\n    0000000: b200 1e5f b300 18b1                    \n"
  },
  {
    "className": "Assumptions$AssumptionMethodInterceptor.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/Assumptions$AssumptionMethodInterceptor.intercept(Lorg/assertj/core/api/AbstractAssert;Ljava/util/concurrent/Callable;)Ljava/lang/Object; @0: invokeinterface\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/AbstractAssert\u0027, \u0027java/util/concurrent/Callable\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b900 1401 002c 2aa5 0033 2cc1 0016 3e1d\n    0000010: 039f 0029 2cc0 0016 3a04 1904 b800 1c3a\n    0000020: 0519 052a b600 1f4b b03a 062c c000 0e19\n    0000030: 07b8 0025 4d2c c000 27bf b0            \n  Exception Handler Table:\n    bci [0, 10] \u003d\u003e handler: 41\n    bci [10, 20] \u003d\u003e handler: 41\n    bci [20, 40] \u003d\u003e handler: 41\n"
  },
  {
    "className": "Assumptions.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/Class[]\" in class file org/assertj/core/api/Assumptions"
  },
  {
    "className": "AtomicBooleanAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AtomicIntegerArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/api/AtomicIntegerArrayAssert"
  },
  {
    "className": "AtomicIntegerAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AtomicIntegerFieldUpdaterAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AtomicLongArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/api/AtomicLongArrayAssert"
  },
  {
    "className": "AtomicLongAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AtomicLongFieldUpdaterAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AtomicMarkableReferenceAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AtomicReferenceArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/api/AtomicReferenceArrayAssert"
  },
  {
    "className": "AtomicReferenceAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "AtomicReferenceFieldUpdaterAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AtomicStampedReferenceAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AutoCloseableBDDSoftAssertions.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/SoftAssertionsProvider has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AutoCloseableSoftAssertions.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/SoftAssertionsProvider has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AutoCloseableSoftAssertionsProvider.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/SoftAssertionsProvider has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "BDDAssertions.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/Assertions has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "BDDAssumptions.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/Class[]\" in class file org/assertj/core/api/Assumptions"
  },
  {
    "className": "BDDSoftAssertions.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/SoftAssertionsProvider has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "BDDSoftAssertionsProvider.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/SoftAssertionsProvider has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "BigDecimalAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "BigDecimalScaleAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "BigIntegerAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "Boolean2DArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"boolean[][]\" in class file org/assertj/core/api/Boolean2DArrayAssert"
  },
  {
    "className": "BooleanArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"boolean[]\" in class file org/assertj/core/api/AbstractBooleanArrayAssert"
  },
  {
    "className": "BooleanAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "Byte2DArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"byte[][]\" in class file org/assertj/core/api/Byte2DArrayAssert"
  },
  {
    "className": "ByteArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"byte[]\" in class file org/assertj/core/api/AbstractByteArrayAssert"
  },
  {
    "className": "ByteAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "Char2DArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"char[][]\" in class file org/assertj/core/api/Char2DArrayAssert"
  },
  {
    "className": "CharacterAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "CharArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"char[]\" in class file org/assertj/core/api/AbstractCharArrayAssert"
  },
  {
    "className": "CharSequenceAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/CharSequence[]\" in class file org/assertj/core/api/AbstractCharSequenceAssert"
  },
  {
    "className": "ClassAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractClassAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "ClassBasedNavigableIterableAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal exception table range in class file org/assertj/core/api/ClassBasedNavigableIterableAssert"
  },
  {
    "className": "ClassBasedNavigableListAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal exception table range in class file org/assertj/core/api/ClassBasedNavigableListAssert"
  },
  {
    "className": "ClassLoadingStrategyFactory$ClassLoadingStrategyPair.class",
    "errorType": "NoClassDefFoundError",
    "errorMessage": "net/bytebuddy/dynamic/loading/ClassLoadingStrategy"
  },
  {
    "className": "ClassLoadingStrategyFactory$CompositeClassLoader.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"byte[]\" in class file org/assertj/core/api/ClassLoadingStrategyFactory$CompositeClassLoader"
  },
  {
    "className": "ClassLoadingStrategyFactory.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack overflow\nException Details:\n  Location:\n    org/assertj/core/api/ClassLoadingStrategyFactory.\u003cclinit\u003e()V @0: invokestatic\n  Reason:\n    Exceeded max stack size.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { }\n    stack: { }\n  Bytecode:\n    0000000: b800 114b 5fb3 0015 1217 2bb6 001d 4d5f\n    0000010: b300 2112 2305 bd00 1959 0312 2553 0412\n    0000020: 2653 2d12 2819 04b6 002c 3a05 a700 083a\n    0000030: 0601 3a05 1905 b300 30b1               \n  Exception Handler Table:\n    bci [19, 44] \u003d\u003e handler: 47\n"
  },
  {
    "className": "CollectionAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractCollectionAssert has illegal signature \"methodtype: int __METHODTYPE__(java.lang.Object,java.lang.Object)\""
  },
  {
    "className": "org.assertj.core.api.ComparableAssert",
    "methods": [
      {
        "name": "isEqualByComparingTo",
        "returnType": "org.assertj.core.api.ComparableAssert"
      },
      {
        "name": "isLessThanOrEqualTo",
        "returnType": "org.assertj.core.api.ComparableAssert"
      },
      {
        "name": "isNotEqualByComparingTo",
        "returnType": "org.assertj.core.api.ComparableAssert"
      },
      {
        "name": "isGreaterThanOrEqualTo",
        "returnType": "org.assertj.core.api.ComparableAssert"
      },
      {
        "name": "isStrictlyBetween",
        "returnType": "org.assertj.core.api.ComparableAssert"
      },
      {
        "name": "isBetween",
        "returnType": "org.assertj.core.api.ComparableAssert"
      },
      {
        "name": "isLessThan",
        "returnType": "org.assertj.core.api.ComparableAssert"
      },
      {
        "name": "isGreaterThan",
        "returnType": "org.assertj.core.api.ComparableAssert"
      }
    ],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "ComparatorFactory$1.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack in putfield\nException Details:\n  Location:\n    org/assertj/core/api/ComparatorFactory$1.\u003cinit\u003e(Lorg/assertj/core/api/ComparatorFactory;D)V @3: putfield\n  Reason:\n    Type uninitializedThis (current frame, stack[1]) is not assignable to \u0027org/assertj/core/api/ComparatorFactory$1\u0027 (constant pool 92)\n  Current Frame:\n    bci: @3\n    flags: { flagThisUninit }\n    locals: { uninitializedThis, \u0027org/assertj/core/api/ComparatorFactory\u0027, double, double_2nd }\n    stack: { uninitializedThis, uninitializedThis, \u0027org/assertj/core/api/ComparatorFactory\u0027 }\n  Bytecode:\n    0000000: 2a2a 2bb5 005c 2a28 b500 17b7 005d b1  \n"
  },
  {
    "className": "ComparatorFactory$2.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack in putfield\nException Details:\n  Location:\n    org/assertj/core/api/ComparatorFactory$2.\u003cinit\u003e(Lorg/assertj/core/api/ComparatorFactory;F)V @3: putfield\n  Reason:\n    Type uninitializedThis (current frame, stack[1]) is not assignable to \u0027org/assertj/core/api/ComparatorFactory$2\u0027 (constant pool 36)\n  Current Frame:\n    bci: @3\n    flags: { flagThisUninit }\n    locals: { uninitializedThis, \u0027org/assertj/core/api/ComparatorFactory\u0027, float }\n    stack: { uninitializedThis, uninitializedThis, \u0027org/assertj/core/api/ComparatorFactory\u0027 }\n  Bytecode:\n    0000000: 2a2a 2bb5 0024 2a24 b500 18b7 0025 b1  \n"
  },
  {
    "className": "ComparatorFactory.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/ComparatorFactory.\u003cclinit\u003e()V @7: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @7\n    flags: { }\n    locals: { }\n    stack: { \u0027org/assertj/core/api/ComparatorFactory\u0027 }\n  Bytecode:\n    0000000: bb00 0259 b700 3b5f b300 3fb1          \n"
  },
  {
    "className": "CompletableFutureAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "Condition$Status.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/api/Condition$Status"
  },
  {
    "className": "Condition.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/Descriptable.as(Lorg/assertj/core/description/Description;)Ljava/lang/Object; @0: invokeinterface\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/Descriptable\u0027, \u0027org/assertj/core/description/Description\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b900 1202 00b0                         \n"
  },
  {
    "className": "DateAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractDateAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "DefaultAssertionErrorCollector.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/DefaultAssertionErrorCollector has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "Descriptable.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/Descriptable.as(Lorg/assertj/core/description/Description;)Ljava/lang/Object; @0: invokeinterface\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/Descriptable\u0027, \u0027org/assertj/core/description/Description\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b900 1202 00b0                         \n"
  },
  {
    "className": "Double2DArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"double[][]\" in class file org/assertj/core/api/Double2DArrayAssert"
  },
  {
    "className": "DoubleArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"double[]\" in class file org/assertj/core/api/AbstractDoubleArrayAssert"
  },
  {
    "className": "DoubleAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "DoublePredicateAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/DoublePredicateAssert has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "DurationAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "org.assertj.core.api.EnumerableAssert",
    "methods": [
      {
        "name": "isEmpty",
        "returnType": "void"
      },
      {
        "name": "isNotEmpty",
        "returnType": "org.assertj.core.api.EnumerableAssert"
      },
      {
        "name": "hasSameSizeAs",
        "returnType": "org.assertj.core.api.EnumerableAssert"
      },
      {
        "name": "hasSameSizeAs",
        "returnType": "org.assertj.core.api.EnumerableAssert"
      },
      {
        "name": "hasSizeLessThan",
        "returnType": "org.assertj.core.api.EnumerableAssert"
      },
      {
        "name": "hasSizeBetween",
        "returnType": "org.assertj.core.api.EnumerableAssert"
      },
      {
        "name": "hasSize",
        "returnType": "org.assertj.core.api.EnumerableAssert"
      },
      {
        "name": "hasSizeGreaterThan",
        "returnType": "org.assertj.core.api.EnumerableAssert"
      },
      {
        "name": "usingDefaultElementComparator",
        "returnType": "org.assertj.core.api.EnumerableAssert"
      },
      {
        "name": "hasSizeLessThanOrEqualTo",
        "returnType": "org.assertj.core.api.EnumerableAssert"
      },
      {
        "name": "hasSizeGreaterThanOrEqualTo",
        "returnType": "org.assertj.core.api.EnumerableAssert"
      },
      {
        "name": "usingElementComparator",
        "returnType": "org.assertj.core.api.EnumerableAssert"
      },
      {
        "name": "isNullOrEmpty",
        "returnType": "void"
      }
    ],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "ErrorCollector.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/ErrorCollector has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "org.assertj.core.api.exception.PathsException",
    "methods": [],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "org.assertj.core.api.ExtensionPoints",
    "methods": [
      {
        "name": "is",
        "returnType": "org.assertj.core.api.ExtensionPoints"
      },
      {
        "name": "has",
        "returnType": "org.assertj.core.api.ExtensionPoints"
      },
      {
        "name": "satisfies",
        "returnType": "org.assertj.core.api.ExtensionPoints"
      },
      {
        "name": "isNot",
        "returnType": "org.assertj.core.api.ExtensionPoints"
      },
      {
        "name": "doesNotHave",
        "returnType": "org.assertj.core.api.ExtensionPoints"
      }
    ],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "FactoryBasedNavigableIterableAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractIterableAssert has illegal signature \"methodtype: void __METHODTYPE__(int)\""
  },
  {
    "className": "FactoryBasedNavigableListAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractCollectionAssert has illegal signature \"methodtype: int __METHODTYPE__(java.lang.Object,java.lang.Object)\""
  },
  {
    "className": "Fail.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/Fail.fail()Ljava/lang/Object; @6: areturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @6\n    flags: { }\n    locals: { \u0027java/lang/Object\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 1239 b800 364b b0                      \n"
  },
  {
    "className": "FileAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "FileSizeAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "FilterOperator.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/api/filter/FilterOperator.\u003cinit\u003e(Ljava/lang/Object;)V @18: checkcast\n  Reason:\n    Type uninitialized 14 (current frame, stack[1]) is not assignable to \u0027java/lang/Object\u0027\n  Current Frame:\n    bci: @18\n    flags: { }\n    locals: { \u0027org/assertj/core/api/filter/FilterOperator\u0027, \u0027java/lang/Object\u0027, integer }\n    stack: { uninitialized 14, uninitialized 14 }\n  Bytecode:\n    0000000: 2ab7 000b 2bc1 0002 3d1c 039f 0013 bb00\n    0000010: 0d59 c000 0d12 0fb7 0012 c000 14bf 2a5f\n    0000020: b500 18b1                              \n  Stackmap Table:\n    full_frame(@30,{Object[#2],Object[#4],Integer},{})\n"
  },
  {
    "className": "Filters.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/filter/Filters has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "InFilter.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/Object[]\" in class file org/assertj/core/api/filter/InFilter"
  },
  {
    "className": "NotFilter.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/api/filter/FilterOperator.\u003cinit\u003e(Ljava/lang/Object;)V @18: checkcast\n  Reason:\n    Type uninitialized 14 (current frame, stack[1]) is not assignable to \u0027java/lang/Object\u0027\n  Current Frame:\n    bci: @18\n    flags: { }\n    locals: { \u0027org/assertj/core/api/filter/FilterOperator\u0027, \u0027java/lang/Object\u0027, integer }\n    stack: { uninitialized 14, uninitialized 14 }\n  Bytecode:\n    0000000: 2ab7 000b 2bc1 0002 3d1c 039f 0013 bb00\n    0000010: 0d59 c000 0d12 0fb7 0012 c000 14bf 2a5f\n    0000020: b500 18b1                              \n  Stackmap Table:\n    full_frame(@30,{Object[#2],Object[#4],Integer},{})\n"
  },
  {
    "className": "NotInFilter.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/Object[]\" in class file org/assertj/core/api/filter/NotInFilter"
  },
  {
    "className": "Float2DArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"float[][]\" in class file org/assertj/core/api/Float2DArrayAssert"
  },
  {
    "className": "FloatArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"float[]\" in class file org/assertj/core/api/AbstractFloatArrayAssert"
  },
  {
    "className": "FloatAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "FloatingPointNumberAssert.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/FloatingPointNumberAssert.isNotCloseTo(Ljava/lang/Number;Lorg/assertj/core/data/Offset;)Lorg/assertj/core/api/NumberAssert; @0: invokeinterface\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/FloatingPointNumberAssert\u0027, \u0027java/lang/Number\u0027, \u0027org/assertj/core/data/Offset\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b900 1003 00b0                         \n"
  },
  {
    "className": "FutureAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "GenericComparableAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "HamcrestCondition.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/Descriptable.as(Lorg/assertj/core/description/Description;)Ljava/lang/Object; @0: invokeinterface\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/Descriptable\u0027, \u0027org/assertj/core/description/Description\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b900 1202 00b0                         \n"
  },
  {
    "className": "org.assertj.core.api.IndexedObjectEnumerableAssert",
    "methods": [
      {
        "name": "contains",
        "returnType": "org.assertj.core.api.IndexedObjectEnumerableAssert"
      },
      {
        "name": "doesNotContain",
        "returnType": "org.assertj.core.api.IndexedObjectEnumerableAssert"
      }
    ],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "InputStreamAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractInputStreamAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "InstanceOfAssertFactories.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/InstanceOfAssertFactories has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "InstanceOfAssertFactory$SyntheticParameterizedType.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/api/InstanceOfAssertFactory$SyntheticParameterizedType"
  },
  {
    "className": "InstanceOfAssertFactory.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/InstanceOfAssertFactory has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "InstantAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractInstantAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "Int2DArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"int[][]\" in class file org/assertj/core/api/Int2DArrayAssert"
  },
  {
    "className": "IntArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"int[]\" in class file org/assertj/core/api/AbstractIntArrayAssert"
  },
  {
    "className": "IntegerAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "IntPredicateAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/IntPredicateAssert has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "Extractor.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/iterable/Extractor.apply(Ljava/lang/Object;)Ljava/lang/Object; @0: invokeinterface\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/iterable/Extractor\u0027, \u0027java/lang/Object\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b900 0b02 00b0                         \n"
  },
  {
    "className": "ThrowingExtractor.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/iterable/ThrowingExtractor.apply(Ljava/lang/Object;)Ljava/lang/Object; @0: invokeinterface\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/iterable/ThrowingExtractor\u0027, \u0027java/lang/Object\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b900 0d02 00b0 4dbb 000f 592b c000 0fb7\n    0000010: 0013 2bc0 0015 bf3a 043a 04bf          \n"
  },
  {
    "className": "IterableAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/IterableAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "IterableSizeAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "IteratorAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractIteratorAssert has illegal signature \"methodtype: void __METHODTYPE__()\""
  },
  {
    "className": "Java6Assertions.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/api/Java6Assertions.offset(Ljava/lang/Double;)Lorg/assertj/core/data/Offset; @4: aload_1\n  Reason:\n    Type top (current frame, locals[1]) is not assignable to reference type\n  Current Frame:\n    bci: @4\n    flags: { }\n    locals: { \u0027java/lang/Double\u0027 }\n    stack: { \u0027java/lang/Number\u0027 }\n  Bytecode:\n    0000000: 2ac0 0069 2bb8 006f 4db0               \n"
  },
  {
    "className": "Java6BDDAssertions.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/Java6BDDAssertions.thenThrownBy(Lorg/assertj/core/api/ThrowableAssert$ThrowingCallable;)Lorg/assertj/core/api/AbstractThrowableAssert; @5: areturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @5\n    flags: { }\n    locals: { \u0027org/assertj/core/api/ThrowableAssert$ThrowingCallable\u0027, \u0027org/assertj/core/api/AbstractThrowableAssert\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2ab8 0079 4cb0                         \n"
  },
  {
    "className": "Java6BDDSoftAssertions.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/SoftAssertionsProvider has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "Java6BDDSoftAssertionsProvider.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/SoftAssertionsProvider has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "Java6JUnitBDDSoftAssertions.class",
    "errorType": "NoClassDefFoundError",
    "errorMessage": "org/junit/rules/TestRule"
  },
  {
    "className": "Java6JUnitSoftAssertions.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/SoftAssertionsProvider has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "Java6SoftAssertions.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/SoftAssertionsProvider has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "Java6StandardSoftAssertionsProvider.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/SoftAssertionsProvider has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "org.assertj.core.api.junit.jupiter.InjectSoftAssertions",
    "methods": [],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "SoftAssertionsExtension$ThreadLocalErrorCollector.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/AssertionErrorCollector.getDelegate()Ljava/util/Optional; @4: areturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @4\n    flags: { }\n    locals: { \u0027org/assertj/core/api/AssertionErrorCollector\u0027, \u0027java/util/Optional\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b800 0d4c b0                           \n"
  },
  {
    "className": "SoftAssertionsExtension.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/junit/jupiter/SoftAssertionsExtension has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "SoftlyExtension.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/junit/jupiter/SoftlyExtension has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "JUnitBDDSoftAssertions.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/SoftAssertionsProvider has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "JUnitJupiterBDDSoftAssertions.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/SoftAssertionsProvider has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "JUnitJupiterSoftAssertions.class",
    "errorType": "NoClassDefFoundError",
    "errorMessage": "org/junit/jupiter/api/extension/AfterEachCallback"
  },
  {
    "className": "JUnitSoftAssertions.class",
    "errorType": "NoClassDefFoundError",
    "errorMessage": "org/junit/rules/TestRule"
  },
  {
    "className": "ListAssert$ListFromStream.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/api/ListAssert$ListFromStream.get(I)Ljava/lang/Object; @8: invokeinterface\n  Reason:\n    Type \u0027java/util/List\u0027 (current frame, stack[1]) is not assignable to integer\n  Current Frame:\n    bci: @8\n    flags: { }\n    locals: { \u0027org/assertj/core/api/ListAssert$ListFromStream\u0027, integer }\n    stack: { \u0027java/util/List\u0027, \u0027java/util/List\u0027 }\n  Bytecode:\n    0000000: 2ab7 0012 2ab4 0016 b900 2f02 00b0     \n"
  },
  {
    "className": "ListAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/ListAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "LocalDateAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractLocalDateAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "LocalDateTimeAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractLocalDateTimeAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "LocalTimeAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractLocalTimeAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "Long2DArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"long[][]\" in class file org/assertj/core/api/Long2DArrayAssert"
  },
  {
    "className": "LongAdderAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "LongArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"long[]\" in class file org/assertj/core/api/AbstractLongArrayAssert"
  },
  {
    "className": "LongAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "LongPredicateAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/LongPredicateAssert has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "MapAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractMapAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object,java.lang.Object)\""
  },
  {
    "className": "MapSizeAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "MatcherAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "NotThrownAssert.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/Descriptable.as(Lorg/assertj/core/description/Description;)Ljava/lang/Object; @0: invokeinterface\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/Descriptable\u0027, \u0027org/assertj/core/description/Description\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b900 1202 00b0                         \n"
  },
  {
    "className": "org.assertj.core.api.NumberAssert",
    "methods": [
      {
        "name": "isZero",
        "returnType": "org.assertj.core.api.NumberAssert"
      },
      {
        "name": "isNegative",
        "returnType": "org.assertj.core.api.NumberAssert"
      },
      {
        "name": "isPositive",
        "returnType": "org.assertj.core.api.NumberAssert"
      },
      {
        "name": "isNotCloseTo",
        "returnType": "org.assertj.core.api.NumberAssert"
      },
      {
        "name": "isNotCloseTo",
        "returnType": "org.assertj.core.api.NumberAssert"
      },
      {
        "name": "isStrictlyBetween",
        "returnType": "org.assertj.core.api.NumberAssert"
      },
      {
        "name": "isBetween",
        "returnType": "org.assertj.core.api.NumberAssert"
      },
      {
        "name": "isNotZero",
        "returnType": "org.assertj.core.api.NumberAssert"
      },
      {
        "name": "isNotNegative",
        "returnType": "org.assertj.core.api.NumberAssert"
      },
      {
        "name": "isCloseTo",
        "returnType": "org.assertj.core.api.NumberAssert"
      },
      {
        "name": "isCloseTo",
        "returnType": "org.assertj.core.api.NumberAssert"
      },
      {
        "name": "isNotPositive",
        "returnType": "org.assertj.core.api.NumberAssert"
      },
      {
        "name": "isOne",
        "returnType": "org.assertj.core.api.NumberAssert"
      }
    ],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "Object2DArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/Object[][]\" in class file org/assertj/core/api/Object2DArrayAssert"
  },
  {
    "className": "ObjectArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/Object[]\" in class file org/assertj/core/api/AbstractObjectArrayAssert"
  },
  {
    "className": "ObjectAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ObjectAssertFactory.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/AssertFactory.createAssert(Lorg/assertj/core/api/AssertFactory$ValueProvider;)Lorg/assertj/core/api/Assert; @0: checkcast\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/AssertFactory\u0027, \u0027org/assertj/core/api/AssertFactory$ValueProvider\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: c000 09b9 000f 0200 b900 1102 00b0     \n"
  },
  {
    "className": "org.assertj.core.api.ObjectEnumerableAssert",
    "methods": [
      {
        "name": "startsWith",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "endsWith",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "endsWith",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "contains",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "anyMatch",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "anyMatch",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "containsAll",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "allMatch",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "allMatch",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "noneMatch",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "noneMatch",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "doesNotContainSequence",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "doesNotContainSequence",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "doesNotHaveAnyElementsOfTypes",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "hasOnlyElementsOfType",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "containsOnlyElementsOf",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "containsAnyElementsOf",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "containsOnlyOnceElementsOf",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "containsExactlyElementsOf",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "doesNotContainSubsequence",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "doesNotContainSubsequence",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "doesNotContainAnyElementsOf",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "hasAtLeastOneElementOfType",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "hasOnlyOneElementSatisfying",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "hasExactlyElementsOfTypes",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "hasOnlyElementsOfTypes",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "satisfiesExactlyInAnyOrder",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "satisfiesExactlyInAnyOrder",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "containsOnly",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "containsOnlyOnce",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "doesNotContain",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "containsAnyOf",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "containsSequence",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "containsSequence",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "containsExactly",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "containsExactlyInAnyOrderElementsOf",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "containsSubsequence",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "containsSubsequence",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "doesNotHaveDuplicates",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "containsExactlyInAnyOrder",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "haveAtLeastOne",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "noneSatisfy",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "noneSatisfy",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "anySatisfy",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "anySatisfy",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "areAtLeastOne",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "satisfiesOnlyOnce",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "satisfiesOnlyOnce",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "haveExactly",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "areAtMost",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "haveAtMost",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "allSatisfy",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "allSatisfy",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "satisfiesExactly",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "satisfiesExactly",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "areExactly",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "containsNull",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "containsOnlyNulls",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "doesNotContainNull",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "areNot",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "haveAtLeast",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "hasSameElementsAs",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "areAtLeast",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "isSubsetOf",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "isSubsetOf",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "are",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "have",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      },
      {
        "name": "doNotHave",
        "returnType": "org.assertj.core.api.ObjectEnumerableAssert"
      }
    ],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "OffsetDateTimeAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "OffsetTimeAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "OptionalAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "OptionalDoubleAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "OptionalIntAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "OptionalLongAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "PathAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "PeriodAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "PredicateAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "ProxifyMethodChangingTheObjectUnderTest.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/api/ProxifyMethodChangingTheObjectUnderTest.actual(Ljava/lang/Object;)Ljava/lang/Object; @20: invokestatic\n  Reason:\n    Type \u0027java/lang/String\u0027 (current frame, stack[1]) is not assignable to \u0027[Ljava/lang/Object;\u0027\n  Current Frame:\n    bci: @20\n    flags: { }\n    locals: { \u0027java/lang/Object\u0027, integer, top, \u0027java/lang/Class\u0027 }\n    stack: { \u0027[Ljava/lang/Object;\u0027, \u0027java/lang/String\u0027 }\n  Bytecode:\n    0000000: 2ac1 003c 3c04 bd00 0459 2ab6 002c 4e03\n    0000010: 2d53 1246 b800 4c2a c000 3c3a 0419 04b4\n    0000020: 004f b0                                \n"
  },
  {
    "className": "AbstractRecursiveOperationConfiguration$AbstractBuilder.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/api/recursive/AbstractRecursiveOperationConfiguration$AbstractBuilder"
  },
  {
    "className": "AbstractRecursiveOperationConfiguration.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/recursive/AbstractRecursiveOperationConfiguration has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "DefaultRecursiveAssertionIntrospectionStrategy.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/recursive/assertion/DefaultRecursiveAssertionIntrospectionStrategy has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration$1",
    "methods": [],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "RecursiveAssertionConfiguration$Builder.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/api/recursive/AbstractRecursiveOperationConfiguration$AbstractBuilder"
  },
  {
    "className": "RecursiveAssertionConfiguration$CollectionAssertionPolicy.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/api/recursive/assertion/RecursiveAssertionConfiguration$CollectionAssertionPolicy"
  },
  {
    "className": "RecursiveAssertionConfiguration$MapAssertionPolicy.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/api/recursive/assertion/RecursiveAssertionConfiguration$MapAssertionPolicy"
  },
  {
    "className": "RecursiveAssertionConfiguration$OptionalAssertionPolicy.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/api/recursive/assertion/RecursiveAssertionConfiguration$OptionalAssertionPolicy"
  },
  {
    "className": "RecursiveAssertionConfiguration.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/recursive/AbstractRecursiveOperationConfiguration has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "RecursiveAssertionDriver.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "RecursiveAssertionIntrospectionStrategy.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/recursive/assertion/RecursiveAssertionIntrospectionStrategy.getDescription()Ljava/lang/String; @0: invokeinterface\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/recursive/assertion/RecursiveAssertionIntrospectionStrategy\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b900 0a01 002b b600 0f4d b0            \n"
  },
  {
    "className": "RecursiveAssertionNode.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack overflow\nException Details:\n  Location:\n    org/assertj/core/api/recursive/assertion/RecursiveAssertionNode.equals(Ljava/lang/Object;)Z @0: aload_0\n  Reason:\n    Exceeded max stack size.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/recursive/assertion/RecursiveAssertionNode\u0027, \u0027java/lang/Object\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2a2b a600 0612 20ac 2b01 a500 122a b600\n    0000010: 244d 2bb6 0024 4e2c 2d9f 0006 1225 ac2b\n    0000020: c000 023a 042a b400 0a19 04b4 000a 1905\n    0000030: 2bb8 0028 3606 1506 039f 0038 2ab4 000e\n    0000040: 1904 b400 0e19 0719 08b8 0028 3606 1506\n    0000050: 039f 0020 2ab4 0012 1904 b400 1219 092c\n    0000060: b800 2836 0a15 0a03 9f00 0904 3606 a700\n    0000070: 0712 2536 06ac                         \n"
  },
  {
    "className": "ComparatorForPatterns.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/recursive/comparison/ComparatorForPatterns has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ComparingFields.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/recursive/comparison/ComparingFields has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ComparingNormalizedFields.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/recursive/comparison/ComparingNormalizedFields has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ComparingProperties.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/recursive/comparison/ComparingProperties has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ComparingSnakeOrCamelCaseFields.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/recursive/comparison/ComparingNormalizedFields has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ComparisonDifference.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/recursive/comparison/ComparisonDifference has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ComparisonKeyDifference.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/recursive/comparison/ComparisonDifference has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "DefaultRecursiveComparisonIntrospectionStrategy.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/recursive/comparison/DefaultRecursiveComparisonIntrospectionStrategy has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "DualValue.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/Class[]\" in class file org/assertj/core/api/recursive/comparison/DualValue"
  },
  {
    "className": "DualValueDeque.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/recursive/comparison/DualValueDeque has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "FieldComparators.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/recursive/comparison/FieldComparators has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "FieldHolder.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/recursive/comparison/FieldHolder has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "FieldLocation.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/recursive/comparison/FieldLocation has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "FieldMessages.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/recursive/comparison/FieldHolder has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "RecursiveComparator.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/api/recursive/comparison/RecursiveComparator.getDescription()Ljava/lang/String; @10: aload_2\n  Reason:\n    Type top (current frame, locals[2]) is not assignable to reference type\n  Current Frame:\n    bci: @10\n    flags: { }\n    locals: { \u0027org/assertj/core/api/recursive/comparison/RecursiveComparator\u0027 }\n    stack: { \u0027[Ljava/lang/Object;\u0027, \u0027[Ljava/lang/Object;\u0027, \u0027org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration\u0027, integer }\n  Bytecode:\n    0000000: 04bd 0004 592a b400 1a03 2c53 121c 2bb8\n    0000010: 0022 4eb0                              \n"
  },
  {
    "className": "org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration$1",
    "methods": [],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "RecursiveComparisonConfiguration$Builder.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration$Builder"
  },
  {
    "className": "RecursiveComparisonConfiguration.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "RecursiveComparisonDifferenceCalculator$ComparisonState.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator$ComparisonState.\u003cinit\u003e(Lorg/assertj/core/api/recursive/comparison/VisitedDualValues;Lorg/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration;)V @8: checkcast\n  Reason:\n    Type uninitialized 4 (current frame, stack[1]) is not assignable to \u0027java/lang/Object\u0027\n  Current Frame:\n    bci: @8\n    flags: { }\n    locals: { \u0027org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator$ComparisonState\u0027, \u0027org/assertj/core/api/recursive/comparison/VisitedDualValues\u0027, \u0027org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration\u0027 }\n    stack: { uninitialized 4, uninitialized 4 }\n  Bytecode:\n    0000000: 2ab7 005f bb00 6159 c000 61b7 0062 2ac0\n    0000010: 0064 b500 682a 2bb5 006c bb00 6e59 2cb7\n    0000020: 0071 2a5f b500 752a 2cb5 0010 b1       \n"
  },
  {
    "className": "RecursiveComparisonDifferenceCalculator.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator"
  },
  {
    "className": "RecursiveComparisonIntrospectionStrategy.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/recursive/comparison/RecursiveComparisonIntrospectionStrategy.getDescription()Ljava/lang/String; @0: invokeinterface\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/recursive/comparison/RecursiveComparisonIntrospectionStrategy\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b900 0c01 002b b600 114d b0            \n"
  },
  {
    "className": "VisitedDualValues$VisitedDualValue.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/api/recursive/comparison/VisitedDualValues$VisitedDualValue.\u003cinit\u003e(Lorg/assertj/core/api/recursive/comparison/DualValue;)V @13: checkcast\n  Reason:\n    Type uninitialized 9 (current frame, stack[1]) is not assignable to \u0027java/lang/Object\u0027\n  Current Frame:\n    bci: @13\n    flags: { }\n    locals: { \u0027org/assertj/core/api/recursive/comparison/VisitedDualValues$VisitedDualValue\u0027, \u0027org/assertj/core/api/recursive/comparison/DualValue\u0027 }\n    stack: { uninitialized 9, uninitialized 9 }\n  Bytecode:\n    0000000: 2ab7 0009 2a2b b500 0dbb 000f 59c0 000f\n    0000010: b700 102a c000 12b5 0016 b1            \n"
  },
  {
    "className": "VisitedDualValues.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/recursive/comparison/VisitedDualValues has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "RecursiveAssertionAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/RecursiveAssertionAssert has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "RecursiveComparisonAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/RecursiveComparisonAssert has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "Short2DArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"short[][]\" in class file org/assertj/core/api/Short2DArrayAssert"
  },
  {
    "className": "ShortArrayAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"short[]\" in class file org/assertj/core/api/AbstractShortArrayAssert"
  },
  {
    "className": "ShortAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "SoftAssertionError.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/api/SoftAssertionError.\u003cinit\u003e(Ljava/util/List;)V @6: invokespecial\n  Reason:\n    Type uninitializedThis (current frame, stack[0]) is not assignable to \u0027java/lang/Object\u0027\n  Current Frame:\n    bci: @6\n    flags: { flagThisUninit }\n    locals: { uninitializedThis, \u0027java/util/List\u0027, \u0027java/lang/String\u0027 }\n    stack: { uninitializedThis }\n  Bytecode:\n    0000000: 2a2b b800 124d b700 152a 2bb5 000a b1  \n"
  },
  {
    "className": "SoftAssertions.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/SoftAssertionsProvider has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "org.assertj.core.api.SoftAssertionsProvider$ThrowingRunnable",
    "methods": [
      {
        "name": "run",
        "returnType": "void"
      }
    ],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "SoftAssertionsProvider.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/SoftAssertionsProvider has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "SoftAssertionsRule.class",
    "errorType": "NoClassDefFoundError",
    "errorMessage": "org/junit/rules/TestRule"
  },
  {
    "className": "SoftAssertionsStatement$1.class",
    "errorType": "NoClassDefFoundError",
    "errorMessage": "org/junit/runners/model/Statement"
  },
  {
    "className": "SoftAssertionsStatement.class",
    "errorType": "NoClassDefFoundError",
    "errorMessage": "org/junit/runners/model/Statement"
  },
  {
    "className": "SoftProxies.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/SoftProxies has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "SoftThrowableAssertAlternative.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "SoftThrowableTypeAssert.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/Descriptable.as(Lorg/assertj/core/description/Description;)Ljava/lang/Object; @0: invokeinterface\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/Descriptable\u0027, \u0027org/assertj/core/description/Description\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b900 1202 00b0                         \n"
  },
  {
    "className": "SpliteratorAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "StandardSoftAssertionsProvider.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/SoftAssertionsProvider has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "StringAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/CharSequence[]\" in class file org/assertj/core/api/AbstractCharSequenceAssert"
  },
  {
    "className": "TemporalAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "org.assertj.core.api.ThrowableAssert$ThrowingCallable",
    "methods": [
      {
        "name": "call",
        "returnType": "void"
      }
    ],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "ThrowableAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractThrowableAssert has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ThrowableAssertAlternative.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ThrowableTypeAssert.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/Descriptable.as(Lorg/assertj/core/description/Description;)Ljava/lang/Object; @0: invokeinterface\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/Descriptable\u0027, \u0027org/assertj/core/description/Description\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b900 1202 00b0                         \n"
  },
  {
    "className": "org.assertj.core.api.ThrowingConsumer",
    "methods": [
      {
        "name": "accept",
        "returnType": "void"
      },
      {
        "name": "acceptThrows",
        "returnType": "void"
      }
    ],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "UniversalComparableAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "UriAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractObjectAssert has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "UrlAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "WithAssertions.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/InstanceOfAssertFactories has illegal signature \"methodtype: org.assertj.core.api.Assert __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "WithAssumptions.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/WithAssumptions.assumeThat(Ljava/util/concurrent/atomic/AtomicIntegerFieldUpdater;)Lorg/assertj/core/api/AtomicIntegerFieldUpdaterAssert; @5: areturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @5\n    flags: { }\n    locals: { \u0027org/assertj/core/api/WithAssumptions\u0027, \u0027java/util/concurrent/atomic/AtomicIntegerFieldUpdater\u0027, \u0027org/assertj/core/api/AtomicIntegerFieldUpdaterAssert\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2bb8 00da 4db0                         \n"
  },
  {
    "className": "WithThrowable.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/WithThrowable.withThrowableOfType(Ljava/lang/Class;)Lorg/assertj/core/api/ThrowableAssertAlternative; @11: checkcast\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @11\n    flags: { }\n    locals: { \u0027org/assertj/core/api/WithThrowable\u0027, \u0027java/lang/Class\u0027, \u0027org/assertj/core/api/ThrowableAssertAlternative\u0027, \u0027org/assertj/core/api/AbstractAssert\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2ab6 0017 4d2c 2bb6 001b 4ec0 0011 3a04\n    0000010: b0                                     \n"
  },
  {
    "className": "WritableAssertionInfo.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/api/WritableAssertionInfo.\u003cinit\u003e()V @7: aload_1\n  Reason:\n    Type top (current frame, locals[1]) is not assignable to reference type\n  Current Frame:\n    bci: @7\n    flags: { }\n    locals: { \u0027org/assertj/core/api/WritableAssertionInfo\u0027 }\n    stack: { \u0027org/assertj/core/configuration/ConfigurationProvider\u0027 }\n  Bytecode:\n    0000000: 2ab7 0054 b200 5a2b b600 5d4d b600 61b1\n    0000010:                                        \n"
  },
  {
    "className": "YearMonthAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/api/AbstractYearMonthAssert has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ZonedDateTimeAssert.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/Object[]\" in class file org/assertj/core/api/AbstractZonedDateTimeAssert"
  },
  {
    "className": "AllOf.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/condition/AllOf has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "AnyOf.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/condition/AnyOf has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "DoesNotHave.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/Descriptable.as(Lorg/assertj/core/description/Description;)Ljava/lang/Object; @0: invokeinterface\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/Descriptable\u0027, \u0027org/assertj/core/description/Description\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b900 1202 00b0                         \n"
  },
  {
    "className": "Join.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/condition/Join has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "MappedCondition.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/Descriptable.as(Lorg/assertj/core/description/Description;)Ljava/lang/Object; @0: invokeinterface\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/Descriptable\u0027, \u0027org/assertj/core/description/Description\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b900 1202 00b0                         \n"
  },
  {
    "className": "Negative.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/Descriptable.as(Lorg/assertj/core/description/Description;)Ljava/lang/Object; @0: invokeinterface\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/Descriptable\u0027, \u0027org/assertj/core/description/Description\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b900 1202 00b0                         \n"
  },
  {
    "className": "NestableCondition$1.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/Descriptable.as(Lorg/assertj/core/description/Description;)Ljava/lang/Object; @0: invokeinterface\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/Descriptable\u0027, \u0027org/assertj/core/description/Description\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b900 1202 00b0                         \n"
  },
  {
    "className": "NestableCondition.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/condition/NestableCondition has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "Not.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/Descriptable.as(Lorg/assertj/core/description/Description;)Ljava/lang/Object; @0: invokeinterface\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/Descriptable\u0027, \u0027org/assertj/core/description/Description\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b900 1202 00b0                         \n"
  },
  {
    "className": "VerboseCondition.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/api/Descriptable.as(Lorg/assertj/core/description/Description;)Ljava/lang/Object; @0: invokeinterface\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/api/Descriptable\u0027, \u0027org/assertj/core/description/Description\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b900 1202 00b0                         \n"
  },
  {
    "className": "Configuration.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/configuration/Configuration has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ConfigurationProvider.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack overflow\nException Details:\n  Location:\n    org/assertj/core/configuration/ConfigurationProvider.\u003cinit\u003e()V @0: aload_0\n  Reason:\n    Exceeded max stack size.\n  Current Frame:\n    bci: @0\n    flags: { flagThisUninit }\n    locals: { uninitializedThis }\n    stack: { }\n  Bytecode:\n    0000000: 2ab7 0013 b200 1812 192b b800 1f4d c000\n    0000010: 154c 2a5f b500 122a b400 12b2 0018 2b2d\n    0000020: 9f00 0a2a b400 12b6 0022 1224 b800 283a\n    0000030: 04bb 002a 5919 04b7 002d 2a5f b500 312a\n    0000040: b400 122b b600 3536 0615 0603 a000 6fb9\n    0000050: 003b 0100 1507 04a0 0023 b200 4104 bd00\n    0000060: 0459 b900 4402 0003 190a 5312 4619 09b8\n    0000070: 004c 3a0b b600 52a7 0071 b900 3b01 0015\n    0000080: 0704 a400 66b2 0041 05bd 0004 59b9 003b\n    0000090: 0100 150e b800 583a 0f03 190f 532a b400\n    00000a0: 3119 10b6 005c 3a11 0419 1153 125e 190d\n    00000b0: b800 4c3a 0bb6 0052 a700 30b9 0061 0100\n    00000c0: 1512 03a0 0025 b200 4105 bd00 0459 0319\n    00000d0: 0453 2ab6 0065 3a13 0419 1353 1267 1909\n    00000e0: b800 4c3a 14b6 0052 b1                 \n"
  },
  {
    "className": "PreferredAssumptionException$1.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/configuration/PreferredAssumptionException$1 has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "PreferredAssumptionException.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/configuration/PreferredAssumptionException has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "Services.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/configuration/Services.get(Ljava/lang/Class;Ljava/lang/Object;)Ljava/lang/Object; @2: aload_2\n  Reason:\n    Type top (current frame, locals[2]) is not assignable to reference type\n  Current Frame:\n    bci: @2\n    flags: { }\n    locals: { \u0027java/lang/Class\u0027, \u0027java/lang/Object\u0027 }\n    stack: { \u0027java/lang/String\u0027 }\n  Bytecode:\n    0000000: 120c 2cb6 0012 4e2a 2db8 0018 3a04 1904\n    0000010: b600 1c3a 05b9 0022 0100 1506 039f 000b\n    0000020: b900 2601 00a7 0003 b900 2201 0015 0803\n    0000030: 9f00 23b2 002c 05bd 0004 5903 2a53 1907\n    0000040: b600 304b 042a 5312 3219 0ab8 0038 3a0b\n    0000050: b600 3eb0                              \n  Stackmap Table:\n    full_frame(@40,{Object[#14],Object[#4],Top,Object[#64],Object[#20],Object[#30]},{Top})\n    same_locals_1_stack_item_frame(@83,Integer)\n"
  },
  {
    "className": "Index.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/data/Index.equals(Ljava/lang/Object;)Z @34: iload\n  Reason:\n    Type top (current frame, locals[4]) is not assignable to integer\n  Current Frame:\n    bci: @34\n    flags: { }\n    locals: { \u0027org/assertj/core/data/Index\u0027, \u0027java/lang/Object\u0027, integer, \u0027org/assertj/core/data/Index\u0027 }\n    stack: { integer, integer }\n  Bytecode:\n    0000000: 2a2b a600 0612 12ac 2bc1 0002 3d1c 03a0\n    0000010: 0006 1213 ac2b c000 024e 2ab4 000a 2db4\n    0000020: 000a 1504 1505 a000 0904 3606 a700 0712\n    0000030: 1336 06ac                              \n  Stackmap Table:\n    same_frame(@8)\n    append_frame(@21,Integer)\n    full_frame(@47,{Object[#2],Object[#4],Integer,Object[#2]},{Integer,Integer})\n    full_frame(@51,{Object[#2],Object[#4],Integer,Object[#2],Top,Top,Integer},{Integer,Integer})\n"
  },
  {
    "className": "MapEntry.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack overflow\nException Details:\n  Location:\n    org/assertj/core/data/MapEntry.equals(Ljava/lang/Object;)Z @0: aload_0\n  Reason:\n    Exceeded max stack size.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/data/MapEntry\u0027, \u0027java/lang/Object\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2a2b a600 0612 1fac 2bc1 0006 3d1c 03a0\n    0000010: 0006 1220 acc0 0006 4e2a b400 17b9 0023\n    0000020: 0100 1904 2bb8 0026 3605 1505 039f 0020\n    0000030: 2ab4 0012 b900 2801 0019 062b b800 2636\n    0000040: 0515 0503 9f00 0904 3605 a700 0712 2036\n    0000050: 05ac                                   \n"
  },
  {
    "className": "Offset.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack overflow\nException Details:\n  Location:\n    org/assertj/core/data/Offset.equals(Ljava/lang/Object;)Z @0: aload_0\n  Reason:\n    Exceeded max stack size.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/data/Offset\u0027, \u0027java/lang/Object\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2a2b a600 0612 07ac 2bc1 0002 3d1c 03a0\n    0000010: 0006 1208 ac2b c000 024e 2ab4 000c 2db4\n    0000020: 000c 1504 1ca0 001d 2ab4 0010 2db4 0010\n    0000030: 1905 1906 b800 153d 1c03 9f00 0804 3da7\n    0000040: 0006 1208 3dac                         \n"
  },
  {
    "className": "Percentage.class",
    "errorType": "VerifyError",
    "errorMessage": "get long/double overflows locals\nException Details:\n  Location:\n    org/assertj/core/data/Percentage.equals(Ljava/lang/Object;)Z @34: dload\n  Reason:\n    Local index 4 is invalid\n  Bytecode:\n    0000000: 2a2b a600 0612 07ac 2bc1 0002 3d1c 03a0\n    0000010: 0006 1208 ac2b c000 024e 2ab4 000c 2db4\n    0000020: 000c 1804 1805 b800 1236 0615 0603 a000\n    0000030: 0904 3607 a700 0712 0836 07ac          \n  Stackmap Table:\n    same_frame(@8)\n    append_frame(@21,Integer)\n    full_frame(@55,{Object[#2],Object[#4],Integer,Object[#2],Top,Top,Integer},{Double,Double})\n    full_frame(@59,{Object[#2],Object[#4],Integer,Object[#2],Top,Top,Integer,Integer},{Double,Double})\n"
  },
  {
    "className": "org.assertj.core.data.TemporalOffset",
    "methods": [
      {
        "name": "getBeyondOffsetDifferenceDescription",
        "returnType": "java.lang.String"
      },
      {
        "name": "isBeyondOffset",
        "returnType": "boolean"
      }
    ],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "TemporalUnitLessThanOffset.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/data/TemporalUnitOffset.\u003cinit\u003e(JLjava/time/temporal/TemporalUnit;)V @4: aload_2\n  Reason:\n    Type long_2nd (current frame, locals[2]) is not assignable to reference type\n  Current Frame:\n    bci: @4\n    flags: { }\n    locals: { \u0027org/assertj/core/data/TemporalUnitOffset\u0027, long, long_2nd, \u0027java/time/temporal/TemporalUnit\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2ab7 0044 2cb8 0048 1fb8 004a 2a1f b500\n    0000010: 332a 2cb5 000c b1                      \n"
  },
  {
    "className": "TemporalUnitOffset.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/data/TemporalUnitOffset.\u003cinit\u003e(JLjava/time/temporal/TemporalUnit;)V @4: aload_2\n  Reason:\n    Type long_2nd (current frame, locals[2]) is not assignable to reference type\n  Current Frame:\n    bci: @4\n    flags: { }\n    locals: { \u0027org/assertj/core/data/TemporalUnitOffset\u0027, long, long_2nd, \u0027java/time/temporal/TemporalUnit\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2ab7 0044 2cb8 0048 1fb8 004a 2a1f b500\n    0000010: 332a 2cb5 000c b1                      \n"
  },
  {
    "className": "TemporalUnitWithinOffset.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/data/TemporalUnitOffset.\u003cinit\u003e(JLjava/time/temporal/TemporalUnit;)V @4: aload_2\n  Reason:\n    Type long_2nd (current frame, locals[2]) is not assignable to reference type\n  Current Frame:\n    bci: @4\n    flags: { }\n    locals: { \u0027org/assertj/core/data/TemporalUnitOffset\u0027, long, long_2nd, \u0027java/time/temporal/TemporalUnit\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2ab7 0044 2cb8 0048 1fb8 004a 2a1f b500\n    0000010: 332a 2cb5 000c b1                      \n"
  },
  {
    "className": "Description.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/description/Description.toString()Ljava/lang/String; @5: areturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @5\n    flags: { }\n    locals: { \u0027org/assertj/core/description/Description\u0027, \u0027java/lang/String\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2ab6 0016 4cb0                         \n"
  },
  {
    "className": "EmptyTextDescription.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/description/TextDescription"
  },
  {
    "className": "JoinDescription$IndentedAppendable.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/description/JoinDescription$IndentedAppendable.toString()Ljava/lang/String; @4: aload_1\n  Reason:\n    Type top (current frame, locals[1]) is not assignable to reference type\n  Current Frame:\n    bci: @4\n    flags: { }\n    locals: { \u0027org/assertj/core/description/JoinDescription$IndentedAppendable\u0027 }\n    stack: { \u0027java/lang/StringBuilder\u0027 }\n  Bytecode:\n    0000000: 2ab4 000c 2bb6 0015 4db0               \n"
  },
  {
    "className": "JoinDescription.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/description/JoinDescription has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "LazyTextDescription.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/description/Description.toString()Ljava/lang/String; @5: areturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @5\n    flags: { }\n    locals: { \u0027org/assertj/core/description/Description\u0027, \u0027java/lang/String\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2ab6 0016 4cb0                         \n"
  },
  {
    "className": "TextDescription.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/description/TextDescription"
  },
  {
    "className": "AbstractShouldHaveTextContent.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/error/AbstractShouldHaveTextContent has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ActualIsNotEmpty.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "AnyElementShouldMatch.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "Array2dElementShouldBeDeepEqual.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "AssertionErrorCreator.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/error/AssertionErrorCreator has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "org.assertj.core.error.AssertionErrorFactory",
    "methods": [
      {
        "name": "newAssertionError",
        "returnType": "java.lang.AssertionError"
      }
    ],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "AssertionErrorMessagesAggregator.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack overflow\nException Details:\n  Location:\n    org/assertj/core/error/AssertionErrorMessagesAggregator.aggregateErrorMessages(Ljava/util/List;)Ljava/lang/String; @0: new\n  Reason:\n    Exceeded max stack size.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027java/util/List\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: bb00 0859 120a b700 0e4d 2a2c b800 122c\n    0000010: 1214 b600 1812 193e b900 1f01 001d 1504\n    0000020: a200 331d 0460 3604 2c15 04b6 0022 4c2b\n    0000030: 1224 b600 184c b900 2802 00c0 002a 3a06\n    0000040: 2b19 06b6 0018 4c12 2cb6 0018 1d04 603e\n    0000050: a7ff c8b8 0032 3a07 2cb6 0036 3a08 03bd\n    0000060: 0004 5919 0701 0119 0819 09b6 003a 3a08\n    0000070: b0                                     \n"
  },
  {
    "className": "AssertionErrorMessagesAggregrator.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/error/AssertionErrorMessagesAggregrator.aggregrateErrorMessages(Ljava/util/List;)Ljava/lang/String; @5: areturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @5\n    flags: { }\n    locals: { \u0027java/util/List\u0027, \u0027java/lang/String\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2ab8 000b 4cb0                         \n"
  },
  {
    "className": "AssertJMultipleFailuresError.class",
    "errorType": "NoClassDefFoundError",
    "errorMessage": "org/opentest4j/MultipleFailuresError"
  },
  {
    "className": "org.assertj.core.error.BasicErrorMessageFactory$1",
    "methods": [],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "BasicErrorMessageFactory$UnquotedString.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/error/BasicErrorMessageFactory$UnquotedString.\u003cinit\u003e(Ljava/lang/String;)V @11: checkcast\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @11\n    flags: { }\n    locals: { \u0027org/assertj/core/error/BasicErrorMessageFactory$UnquotedString\u0027, \u0027java/lang/String\u0027, \u0027java/lang/Object\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2ab7 000b 2b12 0db8 0013 4dc0 0015 4c2a\n    0000010: 5fb5 0019 b1                           \n"
  },
  {
    "className": "BasicErrorMessageFactory.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ClassModifierShouldBe.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ConditionAndGroupGenericParameterTypeShouldBeTheSame.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ConstructorInvoker.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/error/ConstructorInvoker.newInstance(Ljava/lang/String;[Ljava/lang/Class;[Ljava/lang/Object;)Ljava/lang/Object; @22: areturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @22\n    flags: { }\n    locals: { \u0027org/assertj/core/error/ConstructorInvoker\u0027, \u0027java/lang/String\u0027, \u0027[Ljava/lang/Class;\u0027, \u0027[Ljava/lang/Object;\u0027, \u0027java/lang/Class\u0027, \u0027java/lang/reflect/Constructor\u0027, \u0027java/lang/Object\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2bb8 0012 3a04 1904 2cb6 0016 3a05 1905\n    0000010: 2db6 001b 3a06 b0                      \n"
  },
  {
    "className": "DescriptionFormatter.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/error/DescriptionFormatter.\u003cclinit\u003e()V @7: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @7\n    flags: { }\n    locals: { }\n    stack: { \u0027org/assertj/core/error/DescriptionFormatter\u0027 }\n  Bytecode:\n    0000000: bb00 0259 b700 205f b300 24b1          \n"
  },
  {
    "className": "ElementsShouldBe.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ElementsShouldBeAtLeast.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ElementsShouldBeAtMost.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ElementsShouldBeExactly.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ElementsShouldHave.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ElementsShouldHaveAtLeast.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ElementsShouldHaveAtMost.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ElementsShouldHaveExactly.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ElementsShouldMatch.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ElementsShouldNotBe.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ElementsShouldNotHave.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ElementsShouldSatisfy.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/error/ElementsShouldSatisfy has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "org.assertj.core.error.ErrorMessageFactory",
    "methods": [
      {
        "name": "create",
        "returnType": "java.lang.String"
      },
      {
        "name": "create",
        "returnType": "java.lang.String"
      },
      {
        "name": "create",
        "returnType": "java.lang.String"
      }
    ],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "ShouldBeCancelled.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeCompleted.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeCompletedExceptionally.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeCompletedWithin$1.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/future/ShouldBeCompletedWithin$1"
  },
  {
    "className": "ShouldBeCompletedWithin.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/future/ShouldBeCompletedWithin"
  },
  {
    "className": "ShouldBeDone.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveCompletedExceptionallyWithin.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveFailed.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveFailedWithin.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeCancelled.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeCompleted.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeCompletedExceptionally.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeDone.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotHaveFailed.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "org.assertj.core.error.future.Warning",
    "methods": [],
    "instanceCreation": "success"
  },
  {
    "className": "GroupTypeDescription.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/error/GroupTypeDescription.getGroupTypeDescription(Ljava/lang/Object;)Lorg/assertj/core/error/GroupTypeDescription; @10: areturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @10\n    flags: { }\n    locals: { \u0027java/lang/Object\u0027, \u0027java/lang/Class\u0027, \u0027org/assertj/core/error/GroupTypeDescription\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2ab6 0016 4c2b b800 194d b0            \n"
  },
  {
    "className": "MatcherShouldMatch.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "MessageFormatter.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/error/MessageFormatter.\u003cinit\u003e()V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/error/MessageFormatter\u0027, \u0027org/assertj/core/error/DescriptionFormatter\u0027 }\n    stack: { \u0027org/assertj/core/error/MessageFormatter\u0027 }\n  Bytecode:\n    0000000: 2ab7 0008 b800 0e4c 2a5f b500 12b1     \n"
  },
  {
    "className": "MultipleAssertionsError.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/error/MultipleAssertionsError has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "NoElementsShouldMatch.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "NoElementsShouldSatisfy.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "OptionalDoubleShouldHaveValueCloseToOffset.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "OptionalDoubleShouldHaveValueCloseToPercentage.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "OptionalShouldBeEmpty.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "OptionalShouldBePresent.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "OptionalShouldContain.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "OptionalShouldContainInstanceOf.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldAccept.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBe.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeAbsolutePath.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeAbstract.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeAfter.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeAfterOrEqualTo.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeAfterYear.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeAlphabetic.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeAlphanumeric.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeAnArray.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeAnnotation.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeASCII.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeAssignableFrom.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeAssignableTo.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeAtIndex.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeAtSameInstant.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeBase64.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeBefore.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeBeforeOrEqualTo.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeBeforeYear.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeBetween.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeBlank.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeCanonicalPath.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeCloseTo.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeCurrentYearMonth.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeDirectory.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeEmpty.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeEmptyDirectory.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeEqual.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/ShouldBeEqual"
  },
  {
    "className": "ShouldBeEqualByComparingFieldByFieldRecursively.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/error/ShouldBeEqualByComparingFieldByFieldRecursively has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ShouldBeEqualByComparingOnlyGivenFields.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeEqualIgnoringCase.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeEqualIgnoringHours.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeEqualIgnoringMinutes.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeEqualIgnoringNanos.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeEqualIgnoringNewLineDifferences.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeEqualIgnoringNewLines.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeEqualIgnoringSeconds.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeEqualIgnoringTimezone.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeEqualIgnoringWhitespace.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeEqualNormalizingPunctuationAndWhitespace.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeEqualNormalizingUnicode.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeEqualNormalizingWhitespace.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeEqualToIgnoringFields.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeEqualWithinOffset.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeEqualWithinPercentage.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeEqualWithTimePrecision.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeEven.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeExactlyInstanceOf.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeExecutable.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeExhausted.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeFalse.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeFile.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeFinite.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeGreater.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeGreaterOrEqual.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeHexadecimal.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeIn.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeInfinite.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeInSameDay.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeInSameHour.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeInSameHourWindow.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeInSameMinute.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeInSameMinuteWindow.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeInSameMonth.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeInSameSecond.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeInSameSecondWindow.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeInSameYear.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeInstance.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeInstanceOfAny.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeInterface.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeInTheFuture.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeInThePast.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeLess.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeLessOrEqual.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeLowerCase.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeMarked.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeMixedCase.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeNormalized.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeNullOrEmpty.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeNumeric$NumericType.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/ShouldBeNumeric$NumericType"
  },
  {
    "className": "ShouldBeNumeric.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeOdd.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeOfClassIn.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBePeriod.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBePrimitive.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBePrintable.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeReadable.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeRecord.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeRegularFile.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeRelativePath.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeSame.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeSealed.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeSorted.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeSubsetOf.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeSubstring.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeSymbolicLink.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeToday.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeTrue.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeUnmodifiable.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeUpperCase.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeVisible.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldBeWritable.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContain.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/error/ShouldContain has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ShouldContainAnyOf.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainAtIndex.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainCharSequence.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainCharSequenceOnlyOnce.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainEntries.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/error/ShouldContainEntries has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ShouldContainEntry.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainExactly.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainExactlyInAnyOrder$ErrorType.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/ShouldContainExactlyInAnyOrder$ErrorType"
  },
  {
    "className": "ShouldContainExactlyInAnyOrder.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainKey.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainKeys.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainNull.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainOneOrMoreWhitespaces.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainOnly$ErrorType.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/ShouldContainOnly$ErrorType"
  },
  {
    "className": "ShouldContainOnly.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainOnlyDigits.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainOnlyKeys.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainOnlyNulls$1.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/ShouldContainOnlyNulls$1"
  },
  {
    "className": "ShouldContainOnlyNulls$ErrorType.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/ShouldContainOnlyNulls$ErrorType"
  },
  {
    "className": "ShouldContainOnlyNulls.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/ShouldContainOnlyNulls"
  },
  {
    "className": "ShouldContainOnlyWhitespaces.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainPattern.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainRecursively.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainSequence.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainSequenceOfCharSequence.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainsOnlyOnce.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainSubsequence.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainSubsequenceOfCharSequence.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/error/ShouldContainSubsequenceOfCharSequence has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ShouldContainValue.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldContainValues.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldEndWith.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldEndWithIgnoringCase.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldEndWithPath.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldExist.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHave.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveAllNullFields.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveAnnotations.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveAtIndex.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveAtLeastOneElementOfType.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveBinaryContent.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveCause.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveCauseExactlyInstance.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveCauseInstance.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveCauseReference.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveContent.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/error/AbstractShouldHaveTextContent has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ShouldHaveDateField.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveDigest.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveDimensions.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveDuration.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveExactlyTypes.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveExtension.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveFields.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveFileSystem.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveLineCount.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveMessage.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveMessageFindingMatchRegex.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveMessageMatchingRegex.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveMethods.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveName.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveNext.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveNoCause.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveNoExtension.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveNoFields.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveNoNullFields.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveNoPackage.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveNoParent.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveNoSuperclass.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveNoSuppressedExceptions.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveOnlyElementsOfType.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHavePackage.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveParent.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHavePeriod.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHavePermittedSubclasses.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHavePropertyOrField.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHavePropertyOrFieldWithValue.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveRecordComponents.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveReference.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveRootCause.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveRootCauseExactlyInstance.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveRootCauseInstance.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveSameClass.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveSameContent.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/error/AbstractShouldHaveTextContent has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ShouldHaveSameDimensionsAs.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveSameFileSystemAs.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveSameHashCode.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveSameHourAs.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveSameSizeAs.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveSameTime.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveScale.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveSize.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveSizeBetween.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveSizeGreaterThan.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveSizeGreaterThanOrEqualTo.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveSizeLessThan.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveSizeLessThanOrEqualTo.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveStamp.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveSuperclass.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveSuppressedException.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveTime.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveToString.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveValue.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldMatch.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldMatchPattern.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotAccept.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBe.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeBetween.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeBlank.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeEmpty.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeEqual.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeEqualComparingFieldByFieldRecursively.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeEqualIgnoringCase.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeEqualIgnoringWhitespace.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeEqualNormalizingWhitespace.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeEqualWithinOffset.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeEqualWithinPercentage.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeExactlyInstanceOf.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeFinite.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeIn.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeInfinite.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeInstance.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeInstanceOfAny.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeNull.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeOfClassIn.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBePrimitive.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotBeSame.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotContain.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/error/ShouldNotContain has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ShouldNotContainAnyWhitespaces.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotContainAtIndex.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotContainCharSequence.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotContainKey.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotContainKeys.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotContainNull.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotContainOnlyWhitespaces.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotContainPattern.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotContainSequence.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotContainSubsequence.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotContainValue.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotEndWith.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotEndWithIgnoringCase.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotEndWithWhitespaces.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotExist.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotHave.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotHaveAnyElementsOfTypes.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotHaveDuplicates.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotHaveSameClass.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotHaveSameHashCode.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotHaveThrown.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotHaveThrownExcept.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotHaveToString.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotMatch.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotMatchPattern.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotSatisfyPredicateRecursively.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/error/ShouldNotSatisfyPredicateRecursively has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ShouldNotStartWith.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotStartWithIgnoringCase.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldNotStartWithWhitespaces.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldOnlyHaveElementsOfTypes.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldOnlyHaveFields$ErrorType.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/ShouldOnlyHaveFields$ErrorType"
  },
  {
    "className": "ShouldOnlyHaveFields.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldSatisfy.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldSatisfyOnlyOnce.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldStartWith.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldStartWithIgnoringCase.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldStartWithPath.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "SubarraysShouldHaveSameSize.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "UnsatisfiedRequirement.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/error/UnsatisfiedRequirement.\u003cinit\u003e(Ljava/lang/Object;Ljava/lang/AssertionError;)V @15: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @15\n    flags: { }\n    locals: { \u0027org/assertj/core/error/UnsatisfiedRequirement\u0027, \u0027java/lang/Object\u0027, \u0027java/lang/AssertionError\u0027, \u0027java/lang/String\u0027 }\n    stack: { \u0027org/assertj/core/error/UnsatisfiedRequirement\u0027 }\n  Bytecode:\n    0000000: 2ab7 0030 2a2b b500 102c b600 364e 2a5f\n    0000010: b500 3a2a 2cb5 003e b1                 \n"
  },
  {
    "className": "ShouldBeEqualToWithSortedQueryParameters.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveAnchor.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveAuthority.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveFragment.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveHost.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveNoHost.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveParameter.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHavePath.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHavePort.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveProtocol.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveQuery.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveScheme.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ShouldHaveUserInfo.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/error/BasicErrorMessageFactory"
  },
  {
    "className": "ZippedElementsShouldSatisfy$ZipSatisfyError.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/error/ZippedElementsShouldSatisfy$ZipSatisfyError.toString()Ljava/lang/String; @10: aload_2\n  Reason:\n    Type top (current frame, locals[2]) is not assignable to reference type\n  Current Frame:\n    bci: @10\n    flags: { }\n    locals: { \u0027org/assertj/core/error/ZippedElementsShouldSatisfy$ZipSatisfyError\u0027 }\n    stack: { \u0027[Ljava/lang/Object;\u0027, \u0027[Ljava/lang/Object;\u0027, \u0027java/lang/Object\u0027, integer }\n  Bytecode:\n    0000000: 06bd 0004 592a b400 0d03 2c53 2ab4 0010\n    0000010: 042d 532a b400 1405 1904 5312 242b b800\n    0000020: 2a3a 05b0                              \n"
  },
  {
    "className": "ZippedElementsShouldSatisfy.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/error/ZippedElementsShouldSatisfy has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ByNameMultipleExtractor.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/extractor/ByNameMultipleExtractor"
  },
  {
    "className": "ByNameSingleExtractor.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/extractor/ByNameSingleExtractor.apply(Ljava/lang/Object;)Ljava/lang/Object; @7: aload_2\n  Reason:\n    Type top (current frame, locals[2]) is not assignable to reference type\n  Current Frame:\n    bci: @7\n    flags: { }\n    locals: { \u0027org/assertj/core/extractor/ByNameSingleExtractor\u0027, \u0027java/lang/Object\u0027 }\n    stack: { \u0027org/assertj/core/util/introspection/PropertyOrFieldSupport\u0027, \u0027java/lang/String\u0027 }\n  Bytecode:\n    0000000: b200 0e2a b400 122c 2d2b b600 164c b0  \n"
  },
  {
    "className": "Extractors.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/extractor/Extractors has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "ResultOfExtractor.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/extractor/ResultOfExtractor.apply(Ljava/lang/Object;)Ljava/lang/Object; @5: aload_2\n  Reason:\n    Type top (current frame, locals[2]) is not assignable to reference type\n  Current Frame:\n    bci: @5\n    flags: { }\n    locals: { \u0027org/assertj/core/extractor/ResultOfExtractor\u0027, \u0027java/lang/Object\u0027 }\n    stack: { \u0027java/lang/String\u0027, \u0027java/lang/Object\u0027 }\n  Bytecode:\n    0000000: 2ab4 000c 2b2c b800 124c b0            \n"
  },
  {
    "className": "ToStringExtractor.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/extractor/ToStringExtractor.apply(Ljava/lang/Object;)Ljava/lang/String; @5: areturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @5\n    flags: { }\n    locals: { \u0027org/assertj/core/extractor/ToStringExtractor\u0027, \u0027java/lang/Object\u0027, \u0027java/lang/String\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2bb6 0010 4db0                         \n"
  },
  {
    "className": "FieldsOrPropertiesExtractor.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/groups/FieldsOrPropertiesExtractor.extract([Ljava/lang/Object;Ljava/util/function/Function;)[Ljava/lang/Object; @9: checkcast\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027[Ljava/lang/Object;\u0027, \u0027java/util/function/Function\u0027, \u0027java/util/ArrayList\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2ab8 0013 2ab8 0032 4dc0 0034 2d2b b800\n    0000010: 363a 0419 04c0 0034 1905 b800 3c4b b0  \n"
  },
  {
    "className": "Properties.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/groups/Properties.\u003cinit\u003e(Ljava/lang/String;Ljava/lang/Class;)V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/groups/Properties\u0027, \u0027java/lang/String\u0027, \u0027java/lang/Class\u0027, \u0027org/assertj/core/util/introspection/PropertySupport\u0027 }\n    stack: { \u0027org/assertj/core/groups/Properties\u0027 }\n  Bytecode:\n    0000000: 2ab7 004a b800 4e4e 2a5f b500 112a 2bb5\n    0000010: 0015 2a2c b500 19b1                    \n"
  },
  {
    "className": "Tuple.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/groups/Tuple.\u003cinit\u003e([Ljava/lang/Object;)V @10: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @10\n    flags: { }\n    locals: { \u0027org/assertj/core/groups/Tuple\u0027, \u0027[Ljava/lang/Object;\u0027, \u0027java/util/List\u0027 }\n    stack: { \u0027org/assertj/core/groups/Tuple\u0027 }\n  Bytecode:\n    0000000: 2ab7 0023 2bb8 0029 4d2a 5fb5 000a b1  \n"
  },
  {
    "className": "AbstractComparisonStrategy.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/AbstractComparisonStrategy.isLessThanOrEqualTo(Ljava/lang/Object;Ljava/lang/Object;)Z @22: ireturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @22\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/AbstractComparisonStrategy\u0027, \u0027java/lang/Object\u0027, \u0027java/lang/Object\u0027, integer, integer }\n    stack: { }\n  Bytecode:\n    0000000: 2a2b 2cb6 0021 3e1d 03a0 0009 0436 04a7\n    0000010: 0007 120d 3604 ac                      \n  Stackmap Table:\n    append_frame(@18,Integer)\n    append_frame(@22,Integer)\n"
  },
  {
    "className": "Arrays.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal exception table range in class file org/assertj/core/internal/Arrays"
  },
  {
    "className": "Arrays2D.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/Arrays2D.\u003cclinit\u003e()V @7: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @7\n    flags: { }\n    locals: { }\n    stack: { \u0027org/assertj/core/internal/Arrays2D\u0027 }\n  Bytecode:\n    0000000: bb00 0259 b700 935f b300 3fb1          \n"
  },
  {
    "className": "AtomicReferenceArrayElementComparisonStrategy.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/Object[]\" in class file org/assertj/core/internal/AtomicReferenceArrayElementComparisonStrategy"
  },
  {
    "className": "BigDecimals.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/Comparables has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object,java.lang.Object,java.lang.Object)\""
  },
  {
    "className": "BigIntegers.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/Comparables has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object,java.lang.Object,java.lang.Object)\""
  },
  {
    "className": "BinaryDiff.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/BinaryDiff.diff(Ljava/io/File;[B)Lorg/assertj/core/internal/BinaryDiffResult; @13: areturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @13\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/BinaryDiff\u0027, \u0027java/io/File\u0027, \u0027[B\u0027, \u0027java/nio/file/Path\u0027, \u0027org/assertj/core/internal/BinaryDiffResult\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2bb6 0044 4e2a 2d2c b600 463a 04b0     \n"
  },
  {
    "className": "BinaryDiffResult.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/BinaryDiffResult.\u003cinit\u003e(III)V @10: invokespecial\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @10\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/BinaryDiffResult\u0027, integer, integer, integer }\n    stack: { integer }\n  Bytecode:\n    0000000: 2ab7 002e 2a1b b500 0a1c b700 302a 5fb5\n    0000010: 0034 1db7 0030 2a5f b500 37b1          \n"
  },
  {
    "className": "Boolean2DArrays.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/Boolean2DArrays.\u003cinit\u003e()V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/Boolean2DArrays\u0027, \u0027org/assertj/core/internal/Arrays2D\u0027 }\n    stack: { \u0027org/assertj/core/internal/Boolean2DArrays\u0027 }\n  Bytecode:\n    0000000: 2ab7 002c b800 304c 2a5f b500 0ab8 0035\n    0000010: 4d2a 5fb5 0015 b1                      \n"
  },
  {
    "className": "BooleanArrays.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/BooleanArrays.\u003cinit\u003e()V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/BooleanArrays\u0027, \u0027org/assertj/core/internal/Failures\u0027 }\n    stack: { \u0027org/assertj/core/internal/BooleanArrays\u0027 }\n  Bytecode:\n    0000000: 2ab7 0077 b800 7c4c 2a5f b500 15b8 007f\n    0000010: 4db6 0081 b1                           \n"
  },
  {
    "className": "Byte2DArrays.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/Byte2DArrays.\u003cinit\u003e()V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/Byte2DArrays\u0027, \u0027org/assertj/core/internal/Arrays2D\u0027 }\n    stack: { \u0027org/assertj/core/internal/Byte2DArrays\u0027 }\n  Bytecode:\n    0000000: 2ab7 001f b800 224c 2a5f b500 10b8 0027\n    0000010: 4d2a 5fb5 0014 b1                      \n"
  },
  {
    "className": "ByteArrays.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/internal/ByteArrays.\u003cinit\u003e()V @5: invokespecial\n  Reason:\n    Type uninitializedThis (current frame, stack[0]) is not assignable to \u0027org/assertj/core/internal/ComparisonStrategy\u0027\n  Current Frame:\n    bci: @5\n    flags: { flagThisUninit }\n    locals: { uninitializedThis, \u0027org/assertj/core/internal/StandardComparisonStrategy\u0027 }\n    stack: { uninitializedThis }\n  Bytecode:\n    0000000: 2ab8 0063 4cb7 0066 b1                 \n"
  },
  {
    "className": "Bytes.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/Comparables has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object,java.lang.Object,java.lang.Object)\""
  },
  {
    "className": "Char2DArrays.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/Char2DArrays.\u003cinit\u003e()V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/Char2DArrays\u0027, \u0027org/assertj/core/internal/Arrays2D\u0027 }\n    stack: { \u0027org/assertj/core/internal/Char2DArrays\u0027 }\n  Bytecode:\n    0000000: 2ab7 003b b800 3e4c 2a5f b500 0ab8 0043\n    0000010: 4d2a 5fb5 0017 b1                      \n"
  },
  {
    "className": "Characters.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/Comparables has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object,java.lang.Object,java.lang.Object)\""
  },
  {
    "className": "CharArrays.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/internal/CharArrays.\u003cinit\u003e()V @5: invokespecial\n  Reason:\n    Type uninitializedThis (current frame, stack[0]) is not assignable to \u0027org/assertj/core/internal/ComparisonStrategy\u0027\n  Current Frame:\n    bci: @5\n    flags: { flagThisUninit }\n    locals: { uninitializedThis, \u0027org/assertj/core/internal/StandardComparisonStrategy\u0027 }\n    stack: { uninitializedThis }\n  Bytecode:\n    0000000: 2ab8 006d 4cb7 006e b1                 \n"
  },
  {
    "className": "ChronoLocalDateTimeComparator.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/DescribableComparator.toString()Ljava/lang/String; @5: areturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @5\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/DescribableComparator\u0027, \u0027java/lang/String\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2ab6 000f 4cb0                         \n"
  },
  {
    "className": "ChronoZonedDateTimeByInstantComparator.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/DescribableComparator.toString()Ljava/lang/String; @5: areturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @5\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/DescribableComparator\u0027, \u0027java/lang/String\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2ab6 000f 4cb0                         \n"
  },
  {
    "className": "Classes.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/reflect/Member[]\" in class file org/assertj/core/internal/Classes"
  },
  {
    "className": "CommonErrors.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/internal/CommonErrors.wrongElementTypeForFlatExtracting(Ljava/lang/Object;)V @11: aload_2\n  Reason:\n    Type top (current frame, locals[2]) is not assignable to reference type\n  Current Frame:\n    bci: @11\n    flags: { }\n    locals: { \u0027java/lang/Object\u0027 }\n    stack: { uninitialized 0, uninitialized 0, \u0027java/lang/StringBuilder\u0027 }\n  Bytecode:\n    0000000: bb00 0c59 bb00 0e59 b700 0f2c 1211 b600\n    0000010: 154e 2ab6 0019 3a04 1904 b600 1f3a 052d\n    0000020: 1905 b600 154e 2db6 0022 3a06 c000 0cb7\n    0000030: 0025 c000 27bf                         \n"
  },
  {
    "className": "CommonValidations.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/CommonValidations.\u003cclinit\u003e()V @4: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @4\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/Failures\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b800 fd4b 5fb3 0014 b1                 \n"
  },
  {
    "className": "Comparables.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/Comparables has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object,java.lang.Object,java.lang.Object)\""
  },
  {
    "className": "ComparatorBasedComparisonStrategy.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/ComparatorBasedComparisonStrategy has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "org.assertj.core.internal.ComparisonStrategy",
    "methods": [
      {
        "name": "isLessThanOrEqualTo",
        "returnType": "boolean"
      },
      {
        "name": "isGreaterThanOrEqualTo",
        "returnType": "boolean"
      },
      {
        "name": "areEqual",
        "returnType": "boolean"
      },
      {
        "name": "isStandard",
        "returnType": "boolean"
      },
      {
        "name": "duplicatesFrom",
        "returnType": "java.lang.Iterable"
      },
      {
        "name": "iterableContains",
        "returnType": "boolean"
      },
      {
        "name": "arrayContains",
        "returnType": "boolean"
      },
      {
        "name": "stringEndsWith",
        "returnType": "boolean"
      },
      {
        "name": "stringStartsWith",
        "returnType": "boolean"
      },
      {
        "name": "iterableRemoves",
        "returnType": "void"
      },
      {
        "name": "isLessThan",
        "returnType": "boolean"
      },
      {
        "name": "isGreaterThan",
        "returnType": "boolean"
      },
      {
        "name": "iterablesRemoveFirst",
        "returnType": "void"
      },
      {
        "name": "asText",
        "returnType": "java.lang.String"
      },
      {
        "name": "stringContains",
        "returnType": "boolean"
      }
    ],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "Conditions.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/Conditions.\u003cinit\u003e()V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/Conditions\u0027, \u0027org/assertj/core/internal/Failures\u0027 }\n    stack: { \u0027org/assertj/core/internal/Conditions\u0027 }\n  Bytecode:\n    0000000: 2ab7 0051 b800 544c 2a5f b500 14b1     \n"
  },
  {
    "className": "ConfigurableRecursiveFieldByFieldComparator.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator"
  },
  {
    "className": "Dates$1.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/internal/Dates$1"
  },
  {
    "className": "Dates.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/internal/Dates"
  },
  {
    "className": "org.assertj.core.internal.DeepDifference$1",
    "methods": [],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "DeepDifference$Difference.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/DeepDifference$Difference.\u003cinit\u003e(Ljava/util/List;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/String;)V @27: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @27\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/DeepDifference$Difference\u0027, \u0027java/util/List\u0027, \u0027java/lang/Object\u0027, \u0027java/lang/Object\u0027, \u0027java/lang/String\u0027, \u0027java/util/Optional\u0027 }\n    stack: { \u0027org/assertj/core/internal/DeepDifference$Difference\u0027 }\n  Bytecode:\n    0000000: 2ab7 0012 2a2b b500 162a 2cb5 0019 2a2d\n    0000010: b500 0f19 04b8 001f 3a05 2a5f b500 23b1\n    0000020:                                        \n"
  },
  {
    "className": "DeepDifference$DualKey.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack overflow\nException Details:\n  Location:\n    org/assertj/core/internal/DeepDifference$DualKey.equals(Ljava/lang/Object;)Z @0: aload_1\n  Reason:\n    Exceeded max stack size.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/DeepDifference$DualKey\u0027, \u0027java/lang/Object\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2bc1 0002 3d1c 03a0 0006 1240 ac2b c000\n    0000010: 024e 2ab4 0016 2db4 0016 2b19 04a6 0017\n    0000020: 2ab4 001e 2db4 001e 2b19 05a6 0009 0436\n    0000030: 06a7 0007 1240 3606 ac                 \n"
  },
  {
    "className": "DeepDifference.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/internal/DeepDifference.\u003cclinit\u003e()V @4: checkcast\n  Reason:\n    Type uninitialized 0 (current frame, stack[1]) is not assignable to \u0027java/lang/Object\u0027\n  Current Frame:\n    bci: @4\n    flags: { }\n    locals: { }\n    stack: { uninitialized 0, uninitialized 0 }\n  Bytecode:\n    0000000: bb01 4e59 c001 4eb7 014f c000 60b3 0146\n    0000010: bb01 4e59 c001 4eb7 014f c000 60b3 0069\n    0000020: b1                                     \n"
  },
  {
    "className": "DescribableComparator.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/DescribableComparator.toString()Ljava/lang/String; @5: areturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @5\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/DescribableComparator\u0027, \u0027java/lang/String\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2ab6 000f 4cb0                         \n"
  },
  {
    "className": "Diff.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/io/Closeable[]\" in class file org/assertj/core/internal/Diff"
  },
  {
    "className": "DigestDiff.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/internal/DigestDiff.digestsDiffer()Z @8: aload_1\n  Reason:\n    Type top (current frame, locals[1]) is not assignable to reference type\n  Current Frame:\n    bci: @8\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/DigestDiff\u0027 }\n    stack: { \u0027java/lang/String\u0027, \u0027java/lang/String\u0027 }\n  Bytecode:\n    0000000: 2ab4 000a 2ab4 0018 2b2c b600 253e 1d03\n    0000010: a000 0904 3604 a700 0712 2636 04ac     \n  Stackmap Table:\n    full_frame(@25,{Object[#2],Top,Top,Integer},{Object[#33],Object[#33]})\n    full_frame(@29,{Object[#2],Top,Top,Integer,Integer},{Object[#33],Object[#33]})\n"
  },
  {
    "className": "Digests.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/Digests has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "Double2DArrays.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/Double2DArrays.\u003cinit\u003e()V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/Double2DArrays\u0027, \u0027org/assertj/core/internal/Arrays2D\u0027 }\n    stack: { \u0027org/assertj/core/internal/Double2DArrays\u0027 }\n  Bytecode:\n    0000000: 2ab7 003e b800 414c 2a5f b500 0ab8 0046\n    0000010: 4d2a 5fb5 0015 b1                      \n"
  },
  {
    "className": "DoubleArrays.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/DoubleArrays.\u003cinit\u003e(Lorg/assertj/core/internal/ComparisonStrategy;)V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/DoubleArrays\u0027, \u0027org/assertj/core/internal/ComparisonStrategy\u0027, \u0027org/assertj/core/internal/Arrays\u0027 }\n    stack: { \u0027org/assertj/core/internal/DoubleArrays\u0027 }\n  Bytecode:\n    0000000: 2ab7 004f b800 524d 2a5f b500 10b8 0057\n    0000010: 4e2a 5fb5 0014 bb00 1659 2bb7 0059 b600\n    0000020: 5bb1                                   \n"
  },
  {
    "className": "Doubles.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/Comparables has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object,java.lang.Object,java.lang.Object)\""
  },
  {
    "className": "ElementsSatisfyingConsumer.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/ElementsSatisfyingConsumer has illegal signature \"methodtype: boolean __METHODTYPE__(int)\""
  },
  {
    "className": "ErrorMessages.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/internal/ErrorMessages.isNotArray(Ljava/lang/Object;)Ljava/lang/String; @10: aload_1\n  Reason:\n    Type top (current frame, locals[1]) is not assignable to reference type\n  Current Frame:\n    bci: @10\n    flags: { }\n    locals: { \u0027java/lang/Object\u0027 }\n    stack: { \u0027[Ljava/lang/Object;\u0027, \u0027java/lang/String\u0027 }\n  Bytecode:\n    0000000: 04bd 0004 5903 2a53 123e 2bb8 0012 4db0\n    0000010:                                        \n"
  },
  {
    "className": "ExtendedByTypesComparator$1.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/ExtendedByTypesComparator$1.compare(Ljava/lang/Object;Ljava/lang/Object;)I @22: ireturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @22\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/ExtendedByTypesComparator$1\u0027, \u0027java/lang/Object\u0027, \u0027java/lang/Object\u0027, integer, integer }\n    stack: { }\n  Bytecode:\n    0000000: 2b2c b800 123e 1d03 9f00 0a12 1336 04a7\n    0000010: 0007 1214 3604 ac                      \n  Stackmap Table:\n    append_frame(@18,Integer)\n    append_frame(@22,Integer)\n"
  },
  {
    "className": "ExtendedByTypesComparator.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/internal/ExtendedByTypesComparator.toString()Ljava/lang/String; @4: aload_1\n  Reason:\n    Type top (current frame, locals[1]) is not assignable to reference type\n  Current Frame:\n    bci: @4\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/ExtendedByTypesComparator\u0027 }\n    stack: { \u0027org/assertj/core/internal/TypeComparators\u0027 }\n  Bytecode:\n    0000000: 2ab4 000e 2bb6 002c 3d1c 039f 001b 04bd\n    0000010: 0004 592a b400 2403 1904 5312 2e2d b800\n    0000020: 343a 05a7 0021 05bd 0004 592a b400 2403\n    0000030: 1907 532a b400 0e04 1908 5312 3619 06b8\n    0000040: 0034 3a05 b0                           \n  Stackmap Table:\n    full_frame(@38,{Object[#2],Top,Integer},{Object[#20]})\n    full_frame(@68,{Object[#2],Top,Integer,Top,Top,Object[#48]},{Object[#20],Object[#56],Object[#56]})\n"
  },
  {
    "className": "Failures.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/Failures.\u003cclinit\u003e()V @4: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @4\n    flags: { }\n    locals: { \u0027java/lang/String\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b800 5e4b 5fb3 0062 bb00 0259 b700 655f\n    0000010: b300 3ab1                              \n"
  },
  {
    "className": "FieldByFieldComparator.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/FieldByFieldComparator has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "Files.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/Files has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "Float2DArrays.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/Float2DArrays.\u003cinit\u003e()V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/Float2DArrays\u0027, \u0027org/assertj/core/internal/Arrays2D\u0027 }\n    stack: { \u0027org/assertj/core/internal/Float2DArrays\u0027 }\n  Bytecode:\n    0000000: 2ab7 0033 b800 364c 2a5f b500 0ab8 003b\n    0000010: 4d2a 5fb5 000e b1                      \n"
  },
  {
    "className": "FloatArrays.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/FloatArrays.\u003cinit\u003e(Lorg/assertj/core/internal/ComparisonStrategy;)V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/FloatArrays\u0027, \u0027org/assertj/core/internal/ComparisonStrategy\u0027, \u0027org/assertj/core/internal/Arrays\u0027 }\n    stack: { \u0027org/assertj/core/internal/FloatArrays\u0027 }\n  Bytecode:\n    0000000: 2ab7 0089 b800 8c4d 2a5f b500 0ab8 0091\n    0000010: 4e2a 5fb5 000e bb00 1059 2bb7 0092 b600\n    0000020: 94b1                                   \n"
  },
  {
    "className": "Floats.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/Comparables has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object,java.lang.Object,java.lang.Object)\""
  },
  {
    "className": "Futures.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/Futures.\u003cinit\u003e()V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/Futures\u0027, \u0027org/assertj/core/internal/Failures\u0027 }\n    stack: { \u0027org/assertj/core/internal/Futures\u0027 }\n  Bytecode:\n    0000000: 2ab7 0082 b800 854c 2a5f b500 28b1     \n"
  },
  {
    "className": "IgnoringFieldsComparator.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/internal/IgnoringFieldsComparator"
  },
  {
    "className": "IndexedDiff.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack overflow\nException Details:\n  Location:\n    org/assertj/core/internal/IndexedDiff.equals(Ljava/lang/Object;)Z @0: aload_0\n  Reason:\n    Exceeded max stack size.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/IndexedDiff\u0027, \u0027java/lang/Object\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2a2b a600 0612 07ac 2b01 a500 122a b600\n    0000010: 0b4d 2bb6 000b 4e2c 2d9f 0006 120c acc0\n    0000020: 0002 3a04 2ab4 0010 1904 b400 1015 0515\n    0000030: 06a0 0037 2ab4 0014 1904 b400 142b 1907\n    0000040: b800 1936 0815 0803 9f00 202a b400 1c19\n    0000050: 04b4 001c 2b19 09b8 0019 3608 1508 039f\n    0000060: 0009 0436 0aa7 0007 120c 360a ac       \n"
  },
  {
    "className": "Int2DArrays.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/Int2DArrays.\u003cinit\u003e()V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/Int2DArrays\u0027, \u0027org/assertj/core/internal/Arrays2D\u0027 }\n    stack: { \u0027org/assertj/core/internal/Int2DArrays\u0027 }\n  Bytecode:\n    0000000: 2ab7 002e b800 314c 2a5f b500 10b8 0036\n    0000010: 4d2a 5fb5 0014 b1                      \n"
  },
  {
    "className": "IntArrays.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/internal/IntArrays.\u003cinit\u003e()V @5: invokespecial\n  Reason:\n    Type uninitializedThis (current frame, stack[0]) is not assignable to \u0027org/assertj/core/internal/ComparisonStrategy\u0027\n  Current Frame:\n    bci: @5\n    flags: { flagThisUninit }\n    locals: { uninitializedThis, \u0027org/assertj/core/internal/StandardComparisonStrategy\u0027 }\n    stack: { uninitializedThis }\n  Bytecode:\n    0000000: 2ab8 003b 4cb7 003e b1                 \n"
  },
  {
    "className": "Integers.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/Comparables has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object,java.lang.Object,java.lang.Object)\""
  },
  {
    "className": "IterableDiff.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/IterableDiff has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "IterableElementComparisonStrategy.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/StandardComparisonStrategy has illegal signature \"methodtype: int __METHODTYPE__(java.lang.Object,java.lang.Object)\""
  },
  {
    "className": "Iterables$Lifo.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack in putfield\nException Details:\n  Location:\n    org/assertj/core/internal/Iterables$Lifo.\u003cinit\u003e(Lorg/assertj/core/internal/Iterables;I)V @3: putfield\n  Reason:\n    Type uninitializedThis (current frame, stack[1]) is not assignable to \u0027org/assertj/core/internal/Iterables$Lifo\u0027 (constant pool 21)\n  Current Frame:\n    bci: @3\n    flags: { flagThisUninit }\n    locals: { uninitializedThis, \u0027org/assertj/core/internal/Iterables\u0027, integer }\n    stack: { uninitializedThis, uninitializedThis, \u0027org/assertj/core/internal/Iterables\u0027 }\n  Bytecode:\n    0000000: 2a2a 2bb5 0015 b700 322a 1cb5 0026 bb00\n    0000010: 0c59 b700 332a 5fb5 000a b1            \n"
  },
  {
    "className": "Iterables.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/Iterables has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "Iterators.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/Iterators.\u003cinit\u003e()V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/Iterators\u0027, \u0027org/assertj/core/internal/Failures\u0027 }\n    stack: { \u0027org/assertj/core/internal/Iterators\u0027 }\n  Bytecode:\n    0000000: 2ab7 000e b800 134c 2a5f b500 17b1     \n"
  },
  {
    "className": "Lists.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/Lists has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "Long2DArrays.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/Long2DArrays.\u003cinit\u003e()V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/Long2DArrays\u0027, \u0027org/assertj/core/internal/Arrays2D\u0027 }\n    stack: { \u0027org/assertj/core/internal/Long2DArrays\u0027 }\n  Bytecode:\n    0000000: 2ab7 000e b800 134c 2a5f b500 17b8 001c\n    0000010: 4d2a 5fb5 0020 b1                      \n"
  },
  {
    "className": "LongArrays.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/internal/LongArrays.\u003cinit\u003e()V @5: invokespecial\n  Reason:\n    Type uninitializedThis (current frame, stack[0]) is not assignable to \u0027org/assertj/core/internal/ComparisonStrategy\u0027\n  Current Frame:\n    bci: @5\n    flags: { flagThisUninit }\n    locals: { uninitializedThis, \u0027org/assertj/core/internal/StandardComparisonStrategy\u0027 }\n    stack: { uninitializedThis }\n  Bytecode:\n    0000000: 2ab8 0048 4cb7 004b b1                 \n"
  },
  {
    "className": "Longs.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/Comparables has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object,java.lang.Object,java.lang.Object)\""
  },
  {
    "className": "Maps.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/util/Map$Entry[]\" in class file org/assertj/core/internal/Maps"
  },
  {
    "className": "NioFilesWrapper.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/NioFilesWrapper.\u003cclinit\u003e()V @7: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @7\n    flags: { }\n    locals: { }\n    stack: { \u0027org/assertj/core/internal/NioFilesWrapper\u0027 }\n  Bytecode:\n    0000000: bb00 0259 b700 155f b300 19b1          \n"
  },
  {
    "className": "Numbers.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/Comparables has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object,java.lang.Object,java.lang.Object)\""
  },
  {
    "className": "Object2DArrays.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/Object2DArrays.\u003cinit\u003e()V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/Object2DArrays\u0027, \u0027org/assertj/core/internal/Arrays2D\u0027 }\n    stack: { \u0027org/assertj/core/internal/Object2DArrays\u0027 }\n  Bytecode:\n    0000000: 2ab7 0008 b800 0e4c 2a5f b500 12b8 0017\n    0000010: 4d2a 5fb5 001b b1                      \n"
  },
  {
    "className": "ObjectArrayElementComparisonStrategy.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/Object[]\" in class file org/assertj/core/internal/ObjectArrayElementComparisonStrategy"
  },
  {
    "className": "ObjectArrays.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/ObjectArrays has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "org.assertj.core.internal.Objects$1",
    "methods": [],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "Objects$ByFieldsComparison.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/internal/Objects$ByFieldsComparison.isFieldsNamesNotEmpty()Z @4: iload_1\n  Reason:\n    Type top (current frame, locals[1]) is not assignable to integer\n  Current Frame:\n    bci: @4\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/Objects$ByFieldsComparison\u0027 }\n    stack: { integer }\n  Bytecode:\n    0000000: 2ab7 0012 1b03 a000 0804 3da7 0006 1213\n    0000010: 3dac                                   \n  Stackmap Table:\n    same_locals_1_stack_item_frame(@14,Integer)\n    full_frame(@17,{Object[#2],Top,Integer},{Integer})\n"
  },
  {
    "className": "Objects.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/Objects has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "OffsetDateTimeByInstantComparator.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/DescribableComparator.toString()Ljava/lang/String; @5: areturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @5\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/DescribableComparator\u0027, \u0027java/lang/String\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2ab6 000f 4cb0                         \n"
  },
  {
    "className": "OnFieldsComparator.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/internal/OnFieldsComparator"
  },
  {
    "className": "Paths.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/Paths has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "Predicates.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/Predicates.\u003cinit\u003e()V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/Predicates\u0027, \u0027org/assertj/core/internal/Failures\u0027 }\n    stack: { \u0027org/assertj/core/internal/Predicates\u0027 }\n  Bytecode:\n    0000000: 2ab7 000e b800 134c 2a5f b500 17b1     \n"
  },
  {
    "className": "RealNumbers.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/Comparables has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object,java.lang.Object,java.lang.Object)\""
  },
  {
    "className": "RecursiveHelper.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/RecursiveHelper.isContainer(Ljava/lang/Object;)Z @118: ireturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @118\n    flags: { }\n    locals: { \u0027java/lang/Object\u0027, integer, integer }\n    stack: { }\n  Bytecode:\n    0000000: 2ac1 000c 3c1b 03a0 0067 2ac1 000e 3d1c\n    0000010: 03a0 005d 2ac1 0010 3d1c 03a0 0053 2ac1\n    0000020: 0012 3d1c 03a0 0049 2ac1 0014 3d1c 03a0\n    0000030: 003f 2ac1 0016 3d1c 03a0 0035 2ac1 0018\n    0000040: 3d1c 03a0 002b 2ac1 001a 3d1c 03a0 0021\n    0000050: 2ac1 001c 3d1c 03a0 0017 2ac1 001e 3d1c\n    0000060: 03a0 000d 2ab8 0023 3d1c 039f 0008 043d\n    0000070: a700 0612 243d ac                      \n  Stackmap Table:\n    append_frame(@110,Integer)\n    append_frame(@115,Integer)\n    same_frame(@118)\n"
  },
  {
    "className": "Short2DArrays.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/Short2DArrays.\u003cinit\u003e()V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/Short2DArrays\u0027, \u0027org/assertj/core/internal/Arrays2D\u0027 }\n    stack: { \u0027org/assertj/core/internal/Short2DArrays\u0027 }\n  Bytecode:\n    0000000: 2ab7 003e b800 414c 2a5f b500 0ab8 0046\n    0000010: 4d2a 5fb5 000e b1                      \n"
  },
  {
    "className": "ShortArrays.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/internal/ShortArrays.\u003cinit\u003e()V @5: invokespecial\n  Reason:\n    Type uninitializedThis (current frame, stack[0]) is not assignable to \u0027org/assertj/core/internal/ComparisonStrategy\u0027\n  Current Frame:\n    bci: @5\n    flags: { flagThisUninit }\n    locals: { uninitializedThis, \u0027org/assertj/core/internal/StandardComparisonStrategy\u0027 }\n    stack: { uninitializedThis }\n  Bytecode:\n    0000000: 2ab8 0046 4cb7 0049 b1                 \n"
  },
  {
    "className": "Shorts.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/Comparables has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object,java.lang.Object,java.lang.Object)\""
  },
  {
    "className": "Spliterators.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/Spliterators.\u003cinit\u003e()V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/Spliterators\u0027, \u0027org/assertj/core/internal/Iterables\u0027 }\n    stack: { \u0027org/assertj/core/internal/Spliterators\u0027 }\n  Bytecode:\n    0000000: 2ab7 005f b800 624c 2a5f b500 1db1     \n"
  },
  {
    "className": "StandardComparisonStrategy.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/StandardComparisonStrategy has illegal signature \"methodtype: int __METHODTYPE__(java.lang.Object,java.lang.Object)\""
  },
  {
    "className": "Strings.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/Strings has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "Throwables.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/Throwables has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "TypeComparators.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/TypeHolder has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "TypeHolder.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/TypeHolder has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "TypeMessages.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/internal/TypeHolder has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "UnambiguousRepresentation.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack overflow\nException Details:\n  Location:\n    org/assertj/core/internal/UnambiguousRepresentation.\u003cinit\u003e(Lorg/assertj/core/presentation/Representation;Ljava/lang/Object;Ljava/lang/Object;)V @0: aload_0\n  Reason:\n    Exceeded max stack size.\n  Current Frame:\n    bci: @0\n    flags: { flagThisUninit }\n    locals: { uninitializedThis, \u0027org/assertj/core/presentation/Representation\u0027, \u0027java/lang/Object\u0027, \u0027java/lang/Object\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2ab7 000f b900 1502 00b9 0015 0200 1904\n    0000010: 1905 b800 1b36 0615 0603 9f00 0bb9 001e\n    0000020: 0200 a700 032a 1904 b500 2115 0603 9f00\n    0000030: 0bb9 001e 0200 a700 032a 1904 b500 0ab1\n    0000040:                                        \n"
  },
  {
    "className": "Uris.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/Uris.\u003cinit\u003e()V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/Uris\u0027, \u0027org/assertj/core/internal/Failures\u0027 }\n    stack: { \u0027org/assertj/core/internal/Uris\u0027 }\n  Bytecode:\n    0000000: 2ab7 0008 b800 0e4c 2a5f b500 12b1     \n"
  },
  {
    "className": "Urls.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/Urls.\u003cinit\u003e()V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/Urls\u0027, \u0027org/assertj/core/internal/Failures\u0027 }\n    stack: { \u0027org/assertj/core/internal/Urls\u0027 }\n  Bytecode:\n    0000000: 2ab7 00e6 b800 ea4c 2a5f b500 25b1     \n"
  },
  {
    "className": "WholeNumbers.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/internal/WholeNumbers.isOdd(Ljava/lang/Number;)Z @0: invokeinterface\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/internal/WholeNumbers\u0027, \u0027java/lang/Number\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b900 0902 001c 03a0 0008 043e a700 0612\n    0000010: 0a3e ac                                \n"
  },
  {
    "className": "AssertionMatcher.class",
    "errorType": "NoClassDefFoundError",
    "errorMessage": "org/hamcrest/BaseMatcher"
  },
  {
    "className": "BinaryRepresentation.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/Object[]\" in class file org/assertj/core/presentation/StandardRepresentation"
  },
  {
    "className": "BoundedQueue.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/presentation/BoundedQueue.\u003cinit\u003e(I)V @34: invokestatic\n  Reason:\n    Type \u0027java/lang/String\u0027 (current frame, stack[1]) is not assignable to \u0027[Ljava/lang/Object;\u0027\n  Current Frame:\n    bci: @34\n    flags: { }\n    locals: { \u0027org/assertj/core/presentation/BoundedQueue\u0027, integer, integer, top, \u0027java/lang/Integer\u0027 }\n    stack: { \u0027[Ljava/lang/Object;\u0027, \u0027java/lang/String\u0027 }\n  Bytecode:\n    0000000: 2ab7 0029 1b03 a100 0804 3da7 0006 1217\n    0000010: 3d04 bd00 1959 1bb8 002f 3a04 0319 0453\n    0000020: 1231 b800 372a 1bb5 0014 bb00 3959 c000\n    0000030: 39b7 003a 2ac0 000c b500 0ab1          \n  Stackmap Table:\n    full_frame(@14,{Object[#2],Integer},{})\n    append_frame(@17,Integer)\n"
  },
  {
    "className": "CompositeRepresentation.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/presentation/CompositeRepresentation has illegal signature \"methodtype: int __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "HeadTailAccumulator.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack overflow\nException Details:\n  Location:\n    org/assertj/core/presentation/HeadTailAccumulator.\u003cinit\u003e(II)V @0: aload_0\n  Reason:\n    Exceeded max stack size.\n  Current Frame:\n    bci: @0\n    flags: { flagThisUninit }\n    locals: { uninitializedThis, integer, integer }\n    stack: { }\n  Bytecode:\n    0000000: 2ab7 0018 1b03 a100 0804 3ea7 0006 1219\n    0000010: 3e04 bd00 0459 1bb8 001f 3a05 0319 0553\n    0000020: 1221 b800 271c 03a1 0009 0436 06a7 0007\n    0000030: 1219 3606 04bd 0004 591c b800 1f3a 0803\n    0000040: 1908 5312 29b8 0027 bb00 2b59 c000 2b1b\n    0000050: b700 2e2a c000 0cb5 000a bb00 3059 c000\n    0000060: 301c b700 312a c000 0cb5 0013 b1       \n"
  },
  {
    "className": "HexadecimalRepresentation.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/Object[]\" in class file org/assertj/core/presentation/StandardRepresentation"
  },
  {
    "className": "NumberGrouping.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/presentation/NumberGrouping.\u003cclinit\u003e()V @6: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @6\n    flags: { }\n    locals: { \u0027java/util/regex/Pattern\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 1241 b800 454b 5fb3 003d 1247 b800 454c\n    0000010: 5fb3 0032 b1                           \n"
  },
  {
    "className": "PredicateDescription.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/presentation/PredicateDescription.\u003cclinit\u003e()V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { }\n    stack: { \u0027org/assertj/core/presentation/PredicateDescription\u0027 }\n  Bytecode:\n    0000000: bb00 0259 1230 b700 375f b300 3bb1     \n"
  },
  {
    "className": "PrimitiveArrayList.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/presentation/PrimitiveArrayList.\u003cinit\u003e(Ljava/lang/Object;)V @39: invokestatic\n  Reason:\n    Type \u0027java/lang/String\u0027 (current frame, stack[2]) is not assignable to \u0027[Ljava/lang/Object;\u0027\n  Current Frame:\n    bci: @39\n    flags: { }\n    locals: { \u0027org/assertj/core/presentation/PrimitiveArrayList\u0027, \u0027java/lang/Object\u0027, integer, integer }\n    stack: { \u0027[Ljava/lang/Object;\u0027, \u0027[Ljava/lang/Object;\u0027, \u0027java/lang/String\u0027 }\n  Bytecode:\n    0000000: 2ab7 0009 2bb8 000f 3d1c 03a0 000d 2bb8\n    0000010: 0012 3e1d 039f 0008 043e a700 0612 133e\n    0000020: 03bd 0015 5912 17b8 001d 2a2b b500 21b1\n    0000030:                                        \n  Stackmap Table:\n    full_frame(@24,{Object[#2],Object[#21],Integer},{})\n    append_frame(@29,Integer)\n    same_frame(@32)\n"
  },
  {
    "className": "Representation.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/presentation/Representation.unambiguousToStringOf(Ljava/lang/Object;)Ljava/lang/String; @0: invokeinterface\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/presentation/Representation\u0027, \u0027java/lang/Object\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b900 0902 00b0                         \n"
  },
  {
    "className": "RotatingQueue.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/presentation/RotatingQueue.\u003cinit\u003e(I)V @34: invokestatic\n  Reason:\n    Type \u0027java/lang/String\u0027 (current frame, stack[1]) is not assignable to \u0027[Ljava/lang/Object;\u0027\n  Current Frame:\n    bci: @34\n    flags: { }\n    locals: { \u0027org/assertj/core/presentation/RotatingQueue\u0027, integer, integer, top, \u0027java/lang/Integer\u0027 }\n    stack: { \u0027[Ljava/lang/Object;\u0027, \u0027java/lang/String\u0027 }\n  Bytecode:\n    0000000: 2ab7 0017 1b03 a100 0804 3da7 0006 1218\n    0000010: 3d04 bd00 1a59 1bb8 0020 3a04 0319 0453\n    0000020: 1222 b800 282a 1bb5 002c bb00 2e59 c000\n    0000030: 2eb7 002f 2ac0 000c b500 0ab1          \n  Stackmap Table:\n    full_frame(@14,{Object[#2],Integer},{})\n    append_frame(@17,Integer)\n"
  },
  {
    "className": "StandardRepresentation$GroupType.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/presentation/StandardRepresentation$GroupType"
  },
  {
    "className": "StandardRepresentation.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/Object[]\" in class file org/assertj/core/presentation/StandardRepresentation"
  },
  {
    "className": "TransformingList.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/presentation/TransformingList.\u003cinit\u003e(Ljava/util/List;Ljava/util/function/Function;)V @11: checkcast\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @11\n    flags: { }\n    locals: { \u0027org/assertj/core/presentation/TransformingList\u0027, \u0027java/util/List\u0027, \u0027java/util/function/Function\u0027, \u0027java/lang/Object\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2ab7 0009 2b12 0bb8 0011 4ec0 0013 4c2a\n    0000010: 2bb5 0017 2c12 19b8 0011 3a04 c000 1b4d\n    0000020: 2a2c b500 1fb1                         \n"
  },
  {
    "className": "UnicodeRepresentation.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/Object[]\" in class file org/assertj/core/presentation/StandardRepresentation"
  },
  {
    "className": "AbstractComparableNumberComparator.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/util/NullSafeComparator.compare(Ljava/lang/Object;Ljava/lang/Object;)I @31: ireturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @31\n    flags: { }\n    locals: { \u0027org/assertj/core/util/NullSafeComparator\u0027, \u0027java/lang/Object\u0027, \u0027java/lang/Object\u0027, integer }\n    stack: { }\n  Bytecode:\n    0000000: 2b2c a600 0612 09ac 2b01 a600 0612 0aac\n    0000010: 2c01 a600 0612 0bac 2a2b 2cb6 000e 3eac\n    0000020:                                        \n  Stackmap Table:\n    same_frame(@8)\n    same_frame(@16)\n    same_frame(@24)\n"
  },
  {
    "className": "Arrays.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/Object[]\" in class file org/assertj/core/util/Arrays"
  },
  {
    "className": "ArrayWrapperList.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/util/ArrayWrapperList.get(I)Ljava/lang/Object; @9: aload_2\n  Reason:\n    Type top (current frame, locals[2]) is not assignable to reference type\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/util/ArrayWrapperList\u0027, integer }\n    stack: { \u0027java/lang/Object\u0027 }\n  Bytecode:\n    0000000: 2a1b b700 162a b400 0a2c 1bb8 0019 4eb0\n    0000010:                                        \n"
  },
  {
    "className": "BigDecimalComparator.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/util/NullSafeComparator.compare(Ljava/lang/Object;Ljava/lang/Object;)I @31: ireturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @31\n    flags: { }\n    locals: { \u0027org/assertj/core/util/NullSafeComparator\u0027, \u0027java/lang/Object\u0027, \u0027java/lang/Object\u0027, integer }\n    stack: { }\n  Bytecode:\n    0000000: 2b2c a600 0612 09ac 2b01 a600 0612 0aac\n    0000010: 2c01 a600 0612 0bac 2a2b 2cb6 000e 3eac\n    0000020:                                        \n  Stackmap Table:\n    same_frame(@8)\n    same_frame(@16)\n    same_frame(@24)\n"
  },
  {
    "className": "BigIntegerComparator.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/util/NullSafeComparator.compare(Ljava/lang/Object;Ljava/lang/Object;)I @31: ireturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @31\n    flags: { }\n    locals: { \u0027org/assertj/core/util/NullSafeComparator\u0027, \u0027java/lang/Object\u0027, \u0027java/lang/Object\u0027, integer }\n    stack: { }\n  Bytecode:\n    0000000: 2b2c a600 0612 09ac 2b01 a600 0612 0aac\n    0000010: 2c01 a600 0612 0bac 2a2b 2cb6 000e 3eac\n    0000020:                                        \n  Stackmap Table:\n    same_frame(@8)\n    same_frame(@16)\n    same_frame(@24)\n"
  },
  {
    "className": "org.assertj.core.util.CanIgnoreReturnValue",
    "methods": [],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "org.assertj.core.util.CheckReturnValue",
    "methods": [],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "ClassNameComparator.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/util/ClassNameComparator.\u003cclinit\u003e()V @7: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @7\n    flags: { }\n    locals: { }\n    stack: { \u0027org/assertj/core/util/ClassNameComparator\u0027 }\n  Bytecode:\n    0000000: bb00 0259 b700 1c5f b300 20b1          \n"
  },
  {
    "className": "Closeables.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/util/Closeables.\u003cclinit\u003e()V @2: aload_0\n  Reason:\n    Type top (current frame, locals[0]) is not assignable to reference type\n  Current Frame:\n    bci: @2\n    flags: { }\n    locals: { }\n    stack: { \u0027java/lang/String\u0027 }\n  Bytecode:\n    0000000: 1234 2ab6 0039 4c2b b800 3d4d 5fb3 0010\n    0000010: b1                                     \n"
  },
  {
    "className": "DateUtil.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/util/DateUtil.\u003cclinit\u003e()V @4: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @4\n    flags: { }\n    locals: { \u0027java/text/DateFormat\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: b800 d14b 5fb3 0054 b800 d44c 5fb3 0038\n    0000010: b800 d64b 5fb3 0064 b1                 \n"
  },
  {
    "className": "ChangeDelta.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/util/diff/Delta.\u003cinit\u003e(Lorg/assertj/core/util/diff/Chunk;Lorg/assertj/core/util/diff/Chunk;)V @24: invokestatic\n  Reason:\n    Type \u0027java/lang/String\u0027 (current frame, stack[2]) is not assignable to \u0027[Ljava/lang/Object;\u0027\n  Current Frame:\n    bci: @24\n    flags: { }\n    locals: { \u0027org/assertj/core/util/diff/Delta\u0027, \u0027org/assertj/core/util/diff/Chunk\u0027, \u0027org/assertj/core/util/diff/Chunk\u0027, integer }\n    stack: { \u0027[Ljava/lang/Object;\u0027, \u0027[Ljava/lang/Object;\u0027, \u0027java/lang/String\u0027 }\n  Bytecode:\n    0000000: 2ab7 0022 2b01 a500 0804 3ea7 0006 1223\n    0000010: 3e03 bd00 0459 1225 b800 2b2c 01a5 0009\n    0000020: 0436 05a7 0007 1223 3605 03bd 0004 5912\n    0000030: 2db8 002b 2a2b b500 142a 2cb5 0017 b1  \n  Stackmap Table:\n    full_frame(@14,{Object[#2],Object[#12],Object[#12]},{})\n    append_frame(@17,Integer)\n    same_frame(@38)\n    append_frame(@42,Top,Integer)\n"
  },
  {
    "className": "Chunk.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/util/diff/Chunk.equals(Ljava/lang/Object;)Z @28: if_icmpeq\n  Reason:\n    Type \u0027java/lang/Class\u0027 (current frame, stack[1]) is not assignable to integer\n  Current Frame:\n    bci: @28\n    flags: { }\n    locals: { \u0027org/assertj/core/util/diff/Chunk\u0027, \u0027java/lang/Object\u0027, \u0027java/lang/Class\u0027, \u0027java/lang/Class\u0027 }\n    stack: { \u0027java/lang/Class\u0027, \u0027java/lang/Class\u0027 }\n  Bytecode:\n    0000000: 2a2b a600 0612 50ac 2b01 a600 0612 0cac\n    0000010: 2ab6 0054 4d2b b600 544e 2c2d 9f00 0612\n    0000020: 0cac 2bc0 0002 3a04 2ab4 000b 1905 01a0\n    0000030: 002c 1904 b400 0b19 0501 a500 0612 0cac\n    0000040: 2ab4 0014 1904 b400 1415 0615 07a0 0009\n    0000050: 0436 08a7 0007 120c 3608 ac2a b400 0b19\n    0000060: 04b4 000b b900 5502 0015 0a03 a0ff d412\n    0000070: 0cac                                   \n  Stackmap Table:\n    same_frame(@8)\n    same_frame(@16)\n    append_frame(@34,Object[#87],Object[#87])\n    full_frame(@64,{Object[#2],Object[#4],Object[#87],Object[#87],Object[#2]},{Object[#14],Top})\n    full_frame(@86,{Object[#2],Object[#4],Object[#87],Object[#87],Object[#2]},{Object[#14],Top,Integer,Integer})\n    full_frame(@90,{Object[#2],Object[#4],Object[#87],Object[#87],Object[#2],Top,Top,Top,Integer},{Object[#14],Top,Integer,Integer})\n    full_frame(@91,{Object[#2],Object[#4],Object[#87],Object[#87],Object[#2]},{Object[#14]})\n"
  },
  {
    "className": "DeleteDelta.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/util/diff/Delta.\u003cinit\u003e(Lorg/assertj/core/util/diff/Chunk;Lorg/assertj/core/util/diff/Chunk;)V @24: invokestatic\n  Reason:\n    Type \u0027java/lang/String\u0027 (current frame, stack[2]) is not assignable to \u0027[Ljava/lang/Object;\u0027\n  Current Frame:\n    bci: @24\n    flags: { }\n    locals: { \u0027org/assertj/core/util/diff/Delta\u0027, \u0027org/assertj/core/util/diff/Chunk\u0027, \u0027org/assertj/core/util/diff/Chunk\u0027, integer }\n    stack: { \u0027[Ljava/lang/Object;\u0027, \u0027[Ljava/lang/Object;\u0027, \u0027java/lang/String\u0027 }\n  Bytecode:\n    0000000: 2ab7 0022 2b01 a500 0804 3ea7 0006 1223\n    0000010: 3e03 bd00 0459 1225 b800 2b2c 01a5 0009\n    0000020: 0436 05a7 0007 1223 3605 03bd 0004 5912\n    0000030: 2db8 002b 2a2b b500 142a 2cb5 0017 b1  \n  Stackmap Table:\n    full_frame(@14,{Object[#2],Object[#12],Object[#12]},{})\n    append_frame(@17,Integer)\n    same_frame(@38)\n    append_frame(@42,Top,Integer)\n"
  },
  {
    "className": "Delta$TYPE.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/util/diff/Delta$TYPE"
  },
  {
    "className": "Delta.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/util/diff/Delta.\u003cinit\u003e(Lorg/assertj/core/util/diff/Chunk;Lorg/assertj/core/util/diff/Chunk;)V @24: invokestatic\n  Reason:\n    Type \u0027java/lang/String\u0027 (current frame, stack[2]) is not assignable to \u0027[Ljava/lang/Object;\u0027\n  Current Frame:\n    bci: @24\n    flags: { }\n    locals: { \u0027org/assertj/core/util/diff/Delta\u0027, \u0027org/assertj/core/util/diff/Chunk\u0027, \u0027org/assertj/core/util/diff/Chunk\u0027, integer }\n    stack: { \u0027[Ljava/lang/Object;\u0027, \u0027[Ljava/lang/Object;\u0027, \u0027java/lang/String\u0027 }\n  Bytecode:\n    0000000: 2ab7 0022 2b01 a500 0804 3ea7 0006 1223\n    0000010: 3e03 bd00 0459 1225 b800 2b2c 01a5 0009\n    0000020: 0436 05a7 0007 1223 3605 03bd 0004 5912\n    0000030: 2db8 002b 2a2b b500 142a 2cb5 0017 b1  \n  Stackmap Table:\n    full_frame(@14,{Object[#2],Object[#12],Object[#12]},{})\n    append_frame(@17,Integer)\n    same_frame(@38)\n    append_frame(@42,Top,Integer)\n"
  },
  {
    "className": "DeltaComparator.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/util/diff/DeltaComparator.\u003cclinit\u003e()V @7: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @7\n    flags: { }\n    locals: { }\n    stack: { \u0027org/assertj/core/util/diff/DeltaComparator\u0027 }\n  Bytecode:\n    0000000: bb00 0259 b700 0d5f b300 11b1          \n"
  },
  {
    "className": "org.assertj.core.util.diff.DiffAlgorithm",
    "methods": [
      {
        "name": "diff",
        "returnType": "org.assertj.core.util.diff.Patch"
      }
    ],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "DiffUtils.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/String[]\" in class file org/assertj/core/util/diff/DiffUtils"
  },
  {
    "className": "InsertDelta.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/util/diff/Delta.\u003cinit\u003e(Lorg/assertj/core/util/diff/Chunk;Lorg/assertj/core/util/diff/Chunk;)V @24: invokestatic\n  Reason:\n    Type \u0027java/lang/String\u0027 (current frame, stack[2]) is not assignable to \u0027[Ljava/lang/Object;\u0027\n  Current Frame:\n    bci: @24\n    flags: { }\n    locals: { \u0027org/assertj/core/util/diff/Delta\u0027, \u0027org/assertj/core/util/diff/Chunk\u0027, \u0027org/assertj/core/util/diff/Chunk\u0027, integer }\n    stack: { \u0027[Ljava/lang/Object;\u0027, \u0027[Ljava/lang/Object;\u0027, \u0027java/lang/String\u0027 }\n  Bytecode:\n    0000000: 2ab7 0022 2b01 a500 0804 3ea7 0006 1223\n    0000010: 3e03 bd00 0459 1225 b800 2b2c 01a5 0009\n    0000020: 0436 05a7 0007 1223 3605 03bd 0004 5912\n    0000030: 2db8 002b 2a2b b500 142a 2cb5 0017 b1  \n  Stackmap Table:\n    full_frame(@14,{Object[#2],Object[#12],Object[#12]},{})\n    append_frame(@17,Integer)\n    same_frame(@38)\n    append_frame(@42,Top,Integer)\n"
  },
  {
    "className": "DiffNode.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack overflow\nException Details:\n  Location:\n    org/assertj/core/util/diff/myers/PathNode.toString()Ljava/lang/String; @0: new\n  Reason:\n    Exceeded max stack size.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/util/diff/myers/PathNode\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: bb00 2459 1226 b700 294d 2a01 a500 2f2c\n    0000010: 122b b600 2f4c 2ab4 000a 2b1d b600 324c\n    0000020: 2b12 34b6 002f 4c2a b400 0d2b 1504 b600\n    0000030: 324c 1236 b600 2f2a b400 192c 1238 b600\n    0000040: 2f2c b600 3a3a 05b0                    \n"
  },
  {
    "className": "org.assertj.core.util.diff.myers.Equalizer",
    "methods": [
      {
        "name": "equals",
        "returnType": "boolean"
      }
    ],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "MyersDiff.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/util/diff/myers/MyersDiff has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object,java.lang.Object)\""
  },
  {
    "className": "PathNode.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack overflow\nException Details:\n  Location:\n    org/assertj/core/util/diff/myers/PathNode.toString()Ljava/lang/String; @0: new\n  Reason:\n    Exceeded max stack size.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/util/diff/myers/PathNode\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: bb00 2459 1226 b700 294d 2a01 a500 2f2c\n    0000010: 122b b600 2f4c 2ab4 000a 2b1d b600 324c\n    0000020: 2b12 34b6 002f 4c2a b400 0d2b 1504 b600\n    0000030: 324c 1236 b600 2f2a b400 192c 1238 b600\n    0000040: 2f2c b600 3a3a 05b0                    \n"
  },
  {
    "className": "Snake.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack overflow\nException Details:\n  Location:\n    org/assertj/core/util/diff/myers/PathNode.toString()Ljava/lang/String; @0: new\n  Reason:\n    Exceeded max stack size.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/util/diff/myers/PathNode\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: bb00 2459 1226 b700 294d 2a01 a500 2f2c\n    0000010: 122b b600 2f4c 2ab4 000a 2b1d b600 324c\n    0000020: 2b12 34b6 002f 4c2a b400 0d2b 1504 b600\n    0000030: 324c 1236 b600 2f2a b400 192c 1238 b600\n    0000040: 2f2c b600 3a3a 05b0                    \n"
  },
  {
    "className": "Patch.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/util/diff/Patch.\u003cinit\u003e()V @8: checkcast\n  Reason:\n    Type uninitialized 4 (current frame, stack[1]) is not assignable to \u0027java/lang/Object\u0027\n  Current Frame:\n    bci: @8\n    flags: { }\n    locals: { \u0027org/assertj/core/util/diff/Patch\u0027 }\n    stack: { uninitialized 4, uninitialized 4 }\n  Bytecode:\n    0000000: 2ab7 0034 bb00 0a59 c000 0ab7 0035 2ac0\n    0000010: 001a b500 18b1                         \n"
  },
  {
    "className": "DoubleComparator.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/util/NullSafeComparator.compare(Ljava/lang/Object;Ljava/lang/Object;)I @31: ireturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @31\n    flags: { }\n    locals: { \u0027org/assertj/core/util/NullSafeComparator\u0027, \u0027java/lang/Object\u0027, \u0027java/lang/Object\u0027, integer }\n    stack: { }\n  Bytecode:\n    0000000: 2b2c a600 0612 09ac 2b01 a600 0612 0aac\n    0000010: 2c01 a600 0612 0bac 2a2b 2cb6 000e 3eac\n    0000020:                                        \n  Stackmap Table:\n    same_frame(@8)\n    same_frame(@16)\n    same_frame(@24)\n"
  },
  {
    "className": "FailureMessages.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/util/FailureMessages.actualIsEmpty()Ljava/lang/String; @7: aload_0\n  Reason:\n    Type top (current frame, locals[0]) is not assignable to reference type\n  Current Frame:\n    bci: @7\n    flags: { }\n    locals: { }\n    stack: { \u0027[Ljava/lang/Object;\u0027, \u0027[Ljava/lang/Object;\u0027, \u0027java/lang/String\u0027 }\n  Bytecode:\n    0000000: 03bd 0004 5912 112a b800 0e4c b0       \n"
  },
  {
    "className": "Files.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack overflow\nException Details:\n  Location:\n    org/assertj/core/util/Files.delete(Ljava/io/File;)V @0: aload_0\n  Reason:\n    Exceeded max stack size.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027java/io/File\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2ab6 00fb 3c1b 039f 0034 2ab6 00fd 3d1c\n    0000010: 03a0 0029 b201 01bb 0103 59b7 0104 1904\n    0000020: 1301 06b6 0109 3a04 1904 2ab6 010c 3a05\n    0000030: 1905 b601 0d3a 06b6 0112 b12a b600 6c3c\n    0000040: 1b03 a000 04b1 2ab6 0081 3a07 1907 b800\n    0000050: 763c 1b03 a000 2319 08be 1284 360a 150a\n    0000060: 1509 a200 1519 0815 0a32 3a0b 190b b801\n    0000070: 1415 0a04 6036 0a2a b600 fd3c 1b03 a000\n    0000080: 29b2 0101 bb01 0359 b701 0419 0413 0106\n    0000090: b601 093a 0419 042a b601 0c3a 0419 04b6\n    00000a0: 010d 3a0d b601 12b1                    \n"
  },
  {
    "className": "FloatComparator.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/util/NullSafeComparator.compare(Ljava/lang/Object;Ljava/lang/Object;)I @31: ireturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @31\n    flags: { }\n    locals: { \u0027org/assertj/core/util/NullSafeComparator\u0027, \u0027java/lang/Object\u0027, \u0027java/lang/Object\u0027, integer }\n    stack: { }\n  Bytecode:\n    0000000: 2b2c a600 0612 09ac 2b01 a600 0612 0aac\n    0000010: 2c01 a600 0612 0bac 2a2b 2cb6 000e 3eac\n    0000020:                                        \n  Stackmap Table:\n    same_frame(@8)\n    same_frame(@16)\n    same_frame(@24)\n"
  },
  {
    "className": "Hexadecimals.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/util/Hexadecimals"
  },
  {
    "className": "CaseFormatUtils.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/util/introspection/CaseFormatUtils has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(int)\""
  },
  {
    "className": "ClassUtils.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/util/introspection/ClassUtils.\u003cclinit\u003e()V @17: aastore\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @17\n    flags: { }\n    locals: { }\n    stack: { integer, \u0027java/lang/String\u0027 }\n  Bytecode:\n    0000000: 1009 bd00 0f59 0312 3953 0412 3b53 0512\n    0000010: 3d53 0612 3f53 0712 4153 0812 4353 1006\n    0000020: 1245 5310 0712 4753 1008 1249 532a b800\n    0000030: 4f4c 5fb3 0052 07bd 000f 5903 1254 5304\n    0000040: 1256 5305 1258 5306 125a 532c b800 4f4e\n    0000050: 5fb3 0020 b1                           \n"
  },
  {
    "className": "FieldSupport.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/util/introspection/FieldSupport"
  },
  {
    "className": "FieldUtils.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/util/introspection/FieldUtils has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "org.assertj.core.util.introspection.Introspection$1",
    "methods": [],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "Introspection$MethodKey.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack overflow\nException Details:\n  Location:\n    org/assertj/core/util/introspection/Introspection$MethodKey.equals(Ljava/lang/Object;)Z @0: aload_0\n  Reason:\n    Exceeded max stack size.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027org/assertj/core/util/introspection/Introspection$MethodKey\u0027, \u0027java/lang/Object\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2a2b a600 0612 23ac 2b01 a500 122a b600\n    0000010: 274d 2bb6 0027 4e2c 2d9f 0006 1228 ac2b\n    0000020: c000 023a 042a b400 0a19 04b4 000a 1905\n    0000030: 1906 b800 2b36 0715 0703 9f00 202a b400\n    0000040: 1519 04b4 0015 2c19 08b8 002b 3607 1507\n    0000050: 039f 0009 0436 09a7 0007 1228 3609 ac  \n"
  },
  {
    "className": "Introspection.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/util/introspection/Introspection has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "IntrospectionError.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/util/introspection/IntrospectionError.getterInvocationException()Ljava/util/Optional; @4: aload_1\n  Reason:\n    Type top (current frame, locals[1]) is not assignable to reference type\n  Current Frame:\n    bci: @4\n    flags: { }\n    locals: { \u0027org/assertj/core/util/introspection/IntrospectionError\u0027 }\n    stack: { \u0027java/lang/Throwable\u0027 }\n  Bytecode:\n    0000000: 2ab4 000c 2bb8 0013 4db0               \n"
  },
  {
    "className": "MemberUtils.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/util/introspection/MemberUtils.isPackageAccess(I)Z @18: ireturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @18\n    flags: { }\n    locals: { integer, integer }\n    stack: { }\n  Bytecode:\n    0000000: 1a12 2b7e 3b1a 03a0 0008 043c a700 0612\n    0000010: 2c3c ac                                \n  Stackmap Table:\n    same_frame(@15)\n    append_frame(@18,Integer)\n"
  },
  {
    "className": "MethodSupport.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/util/introspection/MethodSupport.methodResultFor(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object; @24: aload\n  Reason:\n    Type top (current frame, locals[4]) is not assignable to reference type\n  Current Frame:\n    bci: @24\n    flags: { }\n    locals: { \u0027java/lang/Object\u0027, \u0027java/lang/String\u0027, top, \u0027java/lang/Class\u0027 }\n    stack: { \u0027java/lang/Object\u0027, \u0027java/lang/CharSequence\u0027, \u0027java/lang/String\u0027 }\n  Bytecode:\n    0000000: 2a12 5cb8 0061 2bc0 0063 1265 b800 692a\n    0000010: b600 6c4e 2bc0 0022 1904 2db8 006e 3a05\n    0000020: 2a19 05b8 0070 4bb0                    \n"
  },
  {
    "className": "PropertyOrFieldSupport.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/util/introspection/PropertyOrFieldSupport.\u003cinit\u003e()V @9: swap\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @9\n    flags: { }\n    locals: { \u0027org/assertj/core/util/introspection/PropertyOrFieldSupport\u0027, \u0027org/assertj/core/util/introspection/PropertySupport\u0027 }\n    stack: { \u0027org/assertj/core/util/introspection/PropertyOrFieldSupport\u0027 }\n  Bytecode:\n    0000000: 2ab7 0064 b800 684c 2a5f b500 2cb8 006c\n    0000010: 4d2a 5fb5 0038 b1                      \n"
  },
  {
    "className": "PropertySupport.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/util/introspection/PropertySupport has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "IterableUtil.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/util/IterableUtil has illegal signature \"methodtype: boolean __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "Lists.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/util/Lists has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "Maps.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/util/Maps.format(Lorg/assertj/core/presentation/Representation;Ljava/util/Map;)Ljava/lang/String; @3: aload_2\n  Reason:\n    Type top (current frame, locals[2]) is not assignable to reference type\n  Current Frame:\n    bci: @3\n    flags: { }\n    locals: { \u0027org/assertj/core/presentation/Representation\u0027, \u0027java/util/Map\u0027 }\n    stack: { \u0027org/assertj/core/configuration/ConfigurationProvider\u0027 }\n  Bytecode:\n    0000000: b200 0c2c b600 104b b900 1602 00b0     \n"
  },
  {
    "className": "NaturalOrderComparator.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/util/NullSafeComparator.compare(Ljava/lang/Object;Ljava/lang/Object;)I @31: ireturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @31\n    flags: { }\n    locals: { \u0027org/assertj/core/util/NullSafeComparator\u0027, \u0027java/lang/Object\u0027, \u0027java/lang/Object\u0027, integer }\n    stack: { }\n  Bytecode:\n    0000000: 2b2c a600 0612 09ac 2b01 a600 0612 0aac\n    0000010: 2c01 a600 0612 0bac 2a2b 2cb6 000e 3eac\n    0000020:                                        \n  Stackmap Table:\n    same_frame(@8)\n    same_frame(@16)\n    same_frame(@24)\n"
  },
  {
    "className": "NullSafeComparator.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/util/NullSafeComparator.compare(Ljava/lang/Object;Ljava/lang/Object;)I @31: ireturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @31\n    flags: { }\n    locals: { \u0027org/assertj/core/util/NullSafeComparator\u0027, \u0027java/lang/Object\u0027, \u0027java/lang/Object\u0027, integer }\n    stack: { }\n  Bytecode:\n    0000000: 2b2c a600 0612 09ac 2b01 a600 0612 0aac\n    0000010: 2c01 a600 0612 0bac 2a2b 2cb6 000e 3eac\n    0000020:                                        \n  Stackmap Table:\n    same_frame(@8)\n    same_frame(@16)\n    same_frame(@24)\n"
  },
  {
    "className": "Objects.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/Object[]\" in class file org/assertj/core/util/Objects"
  },
  {
    "className": "PathNaturalOrderComparator.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/util/NullSafeComparator.compare(Ljava/lang/Object;Ljava/lang/Object;)I @31: ireturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @31\n    flags: { }\n    locals: { \u0027org/assertj/core/util/NullSafeComparator\u0027, \u0027java/lang/Object\u0027, \u0027java/lang/Object\u0027, integer }\n    stack: { }\n  Bytecode:\n    0000000: 2b2c a600 0612 09ac 2b01 a600 0612 0aac\n    0000010: 2c01 a600 0612 0bac 2a2b 2cb6 000e 3eac\n    0000020:                                        \n  Stackmap Table:\n    same_frame(@8)\n    same_frame(@16)\n    same_frame(@24)\n"
  },
  {
    "className": "Paths.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack underflow\nException Details:\n  Location:\n    org/assertj/core/util/Paths.linesOf(Ljava/nio/file/Path;Ljava/lang/String;)Ljava/util/List; @15: areturn\n  Reason:\n    Attempt to pop empty stack.\n  Current Frame:\n    bci: @15\n    flags: { }\n    locals: { \u0027java/nio/file/Path\u0027, \u0027java/lang/String\u0027, \u0027java/nio/charset/Charset\u0027, \u0027java/util/List\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2bb8 0043 2bb8 0047 4d2a 2cb8 0049 4eb0\n    0000010:                                        \n"
  },
  {
    "className": "Preconditions.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal class name \"java/lang/Object[]\" in class file org/assertj/core/util/Preconditions"
  },
  {
    "className": "Sets.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/util/Sets has illegal signature \"methodtype: java.lang.Object __METHODTYPE__()\""
  },
  {
    "className": "Streams.class",
    "errorType": "VerifyError",
    "errorMessage": "Operand stack overflow\nException Details:\n  Location:\n    org/assertj/core/util/Streams.stream(Ljava/lang/Iterable;)Ljava/util/stream/Stream; @0: aload_0\n  Reason:\n    Exceeded max stack size.\n  Current Frame:\n    bci: @0\n    flags: { }\n    locals: { \u0027java/lang/Iterable\u0027 }\n    stack: { }\n  Bytecode:\n    0000000: 2ac1 0008 3c1b 039f 0010 2ac0 0008 4db9\n    0000010: 000b 0100 a700 0fb9 0011 0100 1904 03b8\n    0000020: 0016 4eb0                              \n"
  },
  {
    "className": "Strings$StringsToJoin.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Class name is empty or contains illegal character in descriptor in class file org/assertj/core/util/Strings$StringsToJoin"
  },
  {
    "className": "Strings$StringToAppend.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad local variable type\nException Details:\n  Location:\n    org/assertj/core/util/Strings$StringToAppend.to(Ljava/lang/String;)Ljava/lang/String; @5: aload_2\n  Reason:\n    Type top (current frame, locals[2]) is not assignable to reference type\n  Current Frame:\n    bci: @5\n    flags: { }\n    locals: { \u0027org/assertj/core/util/Strings$StringToAppend\u0027, \u0027java/lang/String\u0027 }\n    stack: { \u0027java/lang/String\u0027, \u0027java/lang/String\u0027 }\n  Bytecode:\n    0000000: 2ab4 000a 2b2c b600 103e 1d03 a000 1905\n    0000010: bd00 0459 032b 532a b400 0a04 2b53 1904\n    0000020: b800 164c b0b0                         \n  Stackmap Table:\n    full_frame(@37,{Object[#2],Object[#12],Top,Integer},{Object[#12]})\n"
  },
  {
    "className": "Strings.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/util/Strings has illegal signature \"methodtype: java.lang.Object __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "TextFileWriter.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal exception table range in class file org/assertj/core/util/TextFileWriter"
  },
  {
    "className": "Throwables.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Method \"type\" in class org/assertj/core/util/Throwables has illegal signature \"methodtype: void __METHODTYPE__(java.lang.Object)\""
  },
  {
    "className": "org.assertj.core.util.TriFunction",
    "methods": [
      {
        "name": "apply",
        "returnType": "java.lang.Object"
      }
    ],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "URLs.class",
    "errorType": "ClassFormatError",
    "errorMessage": "Illegal exception table range in class file org/assertj/core/util/URLs"
  },
  {
    "className": "org.assertj.core.util.VisibleForTesting",
    "methods": [],
    "instanceCreation": "no-arg constructor not available"
  },
  {
    "className": "XmlStringPrettyFormatter.class",
    "errorType": "VerifyError",
    "errorMessage": "Bad type on operand stack\nException Details:\n  Location:\n    org/assertj/core/util/xml/XmlStringPrettyFormatter.xmlPrettyFormat(Ljava/lang/String;)Ljava/lang/String; @20: invokestatic\n  Reason:\n    Type \u0027java/lang/String\u0027 (current frame, stack[2]) is not assignable to \u0027[Ljava/lang/Object;\u0027\n  Current Frame:\n    bci: @20\n    flags: { }\n    locals: { \u0027java/lang/String\u0027, integer }\n    stack: { \u0027[Ljava/lang/Object;\u0027, \u0027[Ljava/lang/Object;\u0027, \u0027java/lang/String\u0027 }\n  Bytecode:\n    0000000: 2a01 a500 0804 3ca7 0006 120b 3c03 bd00\n    0000010: 0459 120d b800 132a b800 174e 2a12 19b6\n    0000020: 001f 3604 2d15 04b8 0023 4bb0          \n  Stackmap Table:\n    same_frame(@10)\n    append_frame(@13,Integer)\n"
  }
]